<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>pyft: User&#39;s guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">pyft
   </div>
   <div id="projectbrief">Python-fortran-tool</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">User's guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md1"></a>
Introduction</h1>
<p>This package contains two python script, <a class="el" href="pyft__tool_8py_source.html">pyft_tool.py</a> and <a class="el" href="pyft__parallel__tool_8py_source.html">pyft_parallel_tool.py</a>, that read FORTRAN codes, parse them in xml, perform some manipulation, revert them in FORTRAN and write them back on disk. <a class="el" href="pyft__tool_8py_source.html">pyft_tool.py</a> performs these tasks on a per file basis whereas <a class="el" href="pyft__parallel__tool_8py_source.html">pyft_parallel_tool.py</a> perform the transformations in parallel on all files found in a tree. In addition, the package can be used for scripting applicative transformations.</p>
<p>This package supposes that the original source code is written using UTF-8 encoding. If not, some special characters could be altered by the double conversion. Apart from this, the resulting FORTRAN source code is exactly the same as the INPUT source code if no manipulation is performed.</p>
<p>DEPENDENCIES:</p>
<ul>
<li><a href="https://github.com/pmarguinaud/fxtran">fxtran</a> must be installed.</li>
<li>pyft needs, at least, version 3.8 of python</li>
</ul>
<p>LIMITATIONS:</p>
<ul>
<li>Depending on where there are put, pre-processor directives can break the parsing by fxtran</li>
<li>Other encoding than UTF-8 is not supported</li>
</ul>
<p>Content of this documentation:</p>
<ul>
<li><a href="#concepts">presentation of the scope path concept</a></li>
<li><a href="#tool-options">tool options</a></li>
<li><a href="#python-module">python module short description</a></li>
<li><a href="#examples-and-tests">examples and tests</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
Concepts</h1>
<p>Especially when a FORTRAN source file contains several subroutine, functions or type declaration, it is necessary to specify on which part of the source code a modification must be done. This is achieved through the scope concept. The scope path is a string representing a kind of path to access the source code fragment on which the action must be performed. A scope path is a succession of path elements separated by '/'; each path elements has one of the following forms:</p>
<ul>
<li><b>module:<em>NAME</em></b> to refer to the module named <em>NAME</em></li>
<li><b>sub:<em>NAME</em></b> to refer to the subroutine named <em>NAME</em></li>
<li><b>func:<em>NAME</em></b> to refer to the function named <em>NAME</em></li>
<li><b>type:<em>NAME</em></b> to refer to the definition of the type named <em>NAME</em></li>
</ul>
<h1><a class="anchor" id="autotoc_md3"></a>
Tool options</h1>
<p>If only one file name is given, the output file will replace the input file.</p>
<p>The order of the arguments matters: transformation are done in that specific order.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Parser options</h2>
<p>**--parser=PATH** can be used to specify the full path to the fxtran executable. Usefull if one wants to use a specific version.</p>
<p>**--parserOption=OPTIONS** the list of available options can be found in the fxtran documentation. If no option is provided, the defaults one will be used (the list of default options can be seen with "pyft.py -h"). In case this option is used, the default options will be replaced by the ones specified.</p>
<p>**--wrapH** Wrap .h file content into a MODULE to enable the parsing by fxtran.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Input and output</h2>
<p>**--renamefF** transforms in upper case the file extension.</p>
<p>**--renameFf** transforms in lower case the file extension.</p>
<p>**--xml=filename** writes the xml file (after transformation) in filename.</p>
<p>**--dryRun** prevents the FORTRAN writting.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
General options</h2>
<p>**--simplify** some transformations may render other parts of the code useless. If this option is set, these parts are automatically removed.</p>
<p>**--logLevel=LEVEL** specifies the log level to use (e.g. debug). With the info level, execution time and number of calls are printed for each called functions. In addition, with the debug level, input and output of all the called functions are printed.</p>
<p>**--enableCache** activates a cache to obtain the node's parent faster.</p>
<p>**--nbPar** sets the number of parallel processes for the pyft_parallel\tool.py tool. 0 (default) to use as many processes as the number of cores.</p>
<p>**--optsByEnv** Name of the environment variable containing additional arguments to use. These arguments are processed after all other arguments. The variable can contain a multi-lines string. The variable is read line by line and the last applicable line is used. A line can take one of these two forms:</p>
<ul>
<li>"FILE_DESCRIPTOR:=:OPTIONS": where FILE_DESCRIPTOR is a regular expression to test against the filename. If there is a match, the OPTIONS can be used for the file.</li>
<li>"OPTIONS": if the line doesn\'t contain the FILE_DESCRIPTOR part, it applies to all source code.</li>
</ul>
<p><b>&ndash;restrictScope SCOPEPATH</b> Limit the action to this scope path (as described in <a href="#concepts">Concepts</a>).</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Dealing with variables</h2>
<p>**--showVariables** displays a list of all the declared variables with some characteristics.</p>
<p>**--removeVariable SCOPEPATH VARNAME** removes the declaration of a local variable, a module variable or of a dummy argument. In the case of a dummy argument, it is also suppresssed from the argument of the subroutine. In case of a module variable, if the module becomes unused, the use statement is also removed. This options takes two argument, the first one describes where the variable is declared (to distinguish between several variables holding the same name but in different subroutines) and the second one is the variable name. The first argument is a scope path as described in <a href="#concepts">Concepts</a>.</p>
<p>**--addVariable SCOPEPATH VARNAME DECLARATION POSITION** adds a new variable. The first argument describes where the variable must be declared (it is a scope path as described in <a href="#concepts">Concepts</a>). The second one is the variable name, the third one is the declarative statement to insert, and the fourth one is the position (python indexing) the new variable will have in the calling statment of the routine (non-integer value for a local variable)</p>
<p><b>&ndash;addModuleVariable SCOPEPATH MODULENAME VARNAME</b> adds a USE statement with an ONLY attribute. The first argument describes where the variable must be declared (it is a scope path as described in <a href="#concepts">Concepts</a>). The second one is the module name and the third one is the variable name.</p>
<p>**--attachArraySpecToEntity** move the array declaration attributes to the right part of the declaration statement (e.g. "REAL, DIMENSION(5) :: X" becomes "REAL :: X(5)")</p>
<p>**--showUnusedVariables** lists the unused varibales.</p>
<p>**--removeUnusedLocalVariables EXCLUDE** remove unused local variables.</p>
<p>**--removePHYEXUnusedLocalVariables EXCLUDE** variation aroud the --removeUnusedLocalVariables to deal with the variables declared in the mnh_expand directives.</p>
<p>**--addExplicitArrayBounds** Adds explicit bounds to arrays that already have parentheses.</p>
<p>**--addArrayParentheses** Adds parentheses to arrays.</p>
<p>**--modifyAutomaticArrays DECL::START::END** modifies all automatic arrays declaration in subroutine and functions. The declaration is replaced by the DECL template, the START template is inserted as first executable statement and the END template as last executable statement. Each template can use the following place holders: "{doubledotshape}", "{shape}", "{lowUpList}", "{name}" and "{type}" which are, respectively modified into ":, :, :", "I, I:J, 0:I", "1, I, I, J, 0, I", "A", "REAL" if the original declaration statement was "A(I, I:J, 0:I)". The template "{type}, DIMENSION({doubledotshape}), ALLOCATABLE :: {name}#ALLOCATE({name}({shape}))#DEALLOCATE({name})" replaces automatic arrays by allocatables.</p>
<p>**--replaceAutomaticWithAllocatable** replace all automatic arrays with allocatables</p>
<p>**--addArgInTree** Add an argument variable recursively begining at the scope path defined with the &ndash;restrictScope option. The first argument is the variable name, the second one is the declarative statement to insert, the third one fourth is the position (python indexing) the new variable will have in the calling statment of the routine. The recursive inclusion of the argument variable stops at the scopes defined by the &ndash;stopScopes option.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
Cosmetics</h2>
<p>**--upperCase** puts the FORTRAN code into upper case letters.</p>
<p>**--lowerCase** puts the FORTRAN code into lower case letters.</p>
<p>**--changeIfStatementsInIfConstructs** transforms one line 'IF' contructs in 'IF-THEN' constructs</p>
<p>**--indent** correct the indentation of the source code.</p>
<p>**--removeIndent** remove the indentation</p>
<p>**--removeEmptyLines** remove empty lines.</p>
<p>**--removeComments** remove the comments.</p>
<p>**--updateSpaces** suppress and/or add spaces. Delimiters and operators must be surrounded by spaces. Commas must be followed by a space. Lines must not end with spaces. Parenthesis must not be surrounded by spaces...</p>
<p>**--alignContinuation** align the beginings of continued lines.</p>
<p>**--addBeginContinuation** add missing continuation characters ('&amp;') at the begining of lines.</p>
<p>**--removeBeginContinuation** remove continuation characters ('&amp;') at the begining of lines.</p>
<p>**--removeALLContinuation** remove all continuation characters('&amp;').</p>
<p>**--pretify** equivalent to &ndash;indent &ndash;upperCase &ndash;removeEmptyLines &ndash;updateSpaces &ndash;addBeginContinuation &ndash;alignContinuation</p>
<p>**--minify** equivalent to &ndash;removeIndent &ndash;upperCase &ndash;removeEmptyLines &ndash;removeComments &ndash;updateSpaces &ndash;removeALLContinuation</p>
<p>**--removeEmptyCONTAINS** removes CONTAINS statement when the section is empty</p>
<h2><a class="anchor" id="autotoc_md9"></a>
Checks</h2>
<p>**--checkIMPLICIT=Warn|Err** if the 'IMPLICIT NONE' statment is missing, issue a warning if option is 'Warn'; otherwise issue an error message and raise an exception.</p>
<p>**--checkINTENT=Warn|Err** if an INTENT attribute is missing for a dummy argument, issue a warning if option is 'Warn'; otherwise issue an error message and raise an exception.</p>
<p>**--checkOpInCall=Warn|Err** if a call argument is an operation, issue a warning if option is 'Warn'; otherwise issue an error message and raise an exception.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Dealing with statements</h2>
<p>**--removeCall CALLNAME** removes call statements. The argument is the subprogram name.</p>
<p>**--removePrints** removes print statements. The argument describes from where the call statements must be suppressed (it is a scope path as described in <a href="#concepts">Concepts</a>).</p>
<p>**--inlineContainedSubroutines** inline containted subroutines in main routine.</p>
<p>**--setFalseIfStmt VAR** replace VAR by .FALSE. in if statements.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Miscellaneous</h2>
<p>**--showScopes** print the different scopes found in the source code.</p>
<p>**--empty** empty the different scopes found in the source code.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Applications</h2>
<p>**--deleteDrHook** removes DrHook statements.</p>
<p>**--addDrHook** adds DrHook statements.</p>
<p>**--deleteBudgetDDH** delete Budget/DDH use.</p>
<p><b>&ndash;deleteRoutineCallsMesoNHGPU</b> Delete parts of the code not compatible with MesoNH-OpenACC such as OCND2 blocks.</p>
<p>**--deleteNonColumnCallsPHYEX** delete call to PHYEX routines that needs information on horizontal points (multiple column dependency).</p>
<p>**--removeIJDim** remove DO I and J dimensions (1, KLON).</p>
<p>**--expandAllArraysPHYEX** expand all array syntax (computing and where block) in DO loops using PHYEX conventions.</p>
<p>**--expandAllArraysPHYEXConcurrent** expand all array syntax (computing and where block) in DO CONCURRENT loops using PHYEX conventions.</p>
<p>**--expandAllArrays** expand all array syntax (computing and where block) in DO loops.</p>
<p>**--expandAllArraysConcurrent** expand all array syntax (computing and where block) in DO CONCURRENT loops.</p>
<p>**--inlineContainedSubroutinesPHYEX** inline containted subroutines in main routine using PHYEX conventions.</p>
<p>**--addStack MODEL** add local automatic arrays to the stack. The argument is the the model name in which stack must be added ("AROME" or "MESONH"). Needs the &ndash;stopScopes argument for the "AROME" case.</p>
<p>**--addIncludes** add .h includes in the file and remove the INCLUDE statement.</p>
<p>**--mnhExpand** apply the mnh_expand directives using DO loops.</p>
<p>**--mnhExpandConcurrent** apply the mnh_expand directives using DO CONCURRENT loops.</p>
<p>**--addMPPDB_CHECKS** Add MPPDB_CHEKS bit-repro checking routines of MesoNH for all in and inout arrays in subroutines.</p>
<p>**--shumanFUNCtoCALL** Transform shuman functions to call statements.</p>
<p>**--mathFunctoBRFunc** Convert intrinsic math functions **, LOG, ATAN, **2, **3, **4, EXP, COS, SIN, ATAN2 into a self defined function BR_ for MesoNH bit-repro.</p>
<p><b>&ndash;convertTypesInCompute</b> Use single variable instead of variable contained in structure in compute statement for optimization issue.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
OpenACC</h2>
<p>**--addACCData** add !$acc data present and !$acc end data directives</p>
<p>**--addACCRoutineSeq** add "!$acc routine seq" to routines called directly or indirectly by scopes defined by the &ndash;stopScopes option.</p>
<p>**--buildACCTypeHelpers** build module files containing helpers to copy user type structures.</p>
<p><b>&ndash;craybyPassDOCONCURRENT</b> remove acc loop independant collapse for BR_ fonctions and mnh_undef(OPENACC) macro use DO CONCURRENT with mnh_undef(LOOP)</p>
<p>**--removeACC** remove ACC directives</p>
<p><b>&ndash;removebyPassDOCONCURRENT</b> remove macro !$mnh_(un)def(OPENACC) and !$mnh_(un)def(LOOP) directives</p>
<h2><a class="anchor" id="autotoc_md14"></a>
Preprocessor</h2>
<p>**--applyCPPifdef** This option is followed by the list of defined or undefined CPP keys. All #ifdef and #ifndef concerning these keys are evaluated. Undefined keys are preceded by a percentage sign '' (e.g. if we use '&ndash;applyCPPifdef K', '#ifdef K' is evaluated to True; whereas if we use '&ndash;applyCPPifdef K', '#ifdef K' is evaluated to False. But the method does not evaluate more complicated cpp directives such as '#if defined'.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
Tree</h2>
<p>**--tree** Directories where source code must be searched for.</p>
<p>**--descTree** File name where the description of the tree is stored. If the file doesn't exist, it will be created using the --tree option.</p>
<p>**--plotCompilTree** File name for compilation dependency graph (.dot or image extension). If --descTree is used, the descTree file will be used, otherwise the tree (provided with the --tree option) is explored. See --plotMaxUpper and --plotMaxLower options.</p>
<p>**--plotExecTree** File name for the calling graph (.dot or image extension). If --descTree is used, the descTree file will be used, otherwise the tree (provided with the --tree option) is explored. See --plotMaxUpper and --plotMaxLower options.</p>
<p>**--plotMaxUpper** Maximum number of elements to plot, upper than the central element.</p>
<p>**--plotMaxLower** Maximum number of elements to plot, lower than the central element.</p>
<p>**--stopScopes** #-separated list of scopes where the recursive inclusion of an argument variable must stop (needed for some transformations)</p>
<h1><a class="anchor" id="autotoc_md16"></a>
Python module</h1>
<h2><a class="anchor" id="autotoc_md17"></a>
Module overview</h2>
<p>The main objet is the PYFTscope one; this class represents a FORTRAN scope (module, subroutine, function, program or type). To ease the development, the different methods of this class have been distributed to several files. In each of these files the defined methods are attached to an abstract class (Variables in <a class="el" href="variables_8py_source.html">variables.py</a>, Statements in <a class="el" href="statements_8py_source.html">statements.py</a> and so on for <a class="el" href="applications_8py_source.html">applications.py</a>, <a class="el" href="cosmetics_8py_source.html">cosmetics.py</a>, <a class="el" href="cpp_8py_source.html">cpp.py</a> and <a class="el" href="openacc_8py_source.html">openacc.py</a>). The main class PYFTscope is built by inhereting from all of these classes but none of them is directly usable (cross-dependencies).</p>
<p>The PYFTscope is not directly instantiable because it doesn't contain read/write feature. The PYFT class extends the PYFTscope class with those features. And so, PYFT is the class publicly exposed.</p>
<p>An instance of PYFT represents the entire file and can contain several FORTRAN scopes. If p is an instance of PYFT, p.getScopes() returns a list of PYFTscope instances, each one representing a specific FORTRAN scope.</p>
<p>In order to deal with complex operations involving several source code files, a Tree object can be created. This object analizes all the source code files present in the specified directories to build a compilation tree and an execution tree. These trees can be explored and/or plotted through methods of this object.</p>
<p>Another class, VarList, represents the list of variables defined in a scope.</p>
<p>In addition to these four classes, the module contains some functions in <a class="el" href="namespacepyft_1_1util.html">pyft.util</a> and <a class="el" href="namespacepyft_1_1expressions.html">pyft.expressions</a>.</p>
<h2><a class="anchor" id="autotoc_md18"></a>
The developer's point of view</h2>
<h3><a class="anchor" id="autotoc_md19"></a>
Separation into modules</h3>
<p>New methods must be added in one of the abstract classes defined in <a class="el" href="variables_8py_source.html">variables.py</a>, <a class="el" href="statements_8py_source.html">statements.py</a>... according to its main topic. The application.py file deals with methods specific to PHYEX that are not universal. The <a class="el" href="scripting_8py_source.html">scripting.py</a> modules contains functions used to build the two main tools.</p>
<p>Several decorators are available:</p><ul>
<li>debugDecor (defined in tool): ease the debugging/profiling when logLevel is set to info or debug. The additional cost is low, except when the method is called many times; in this case, the decorator should not be used.</li>
<li>updateTree() (defined in tree): this decorator should be used for methods that can modify the execution tree. When decorated, the file is analized again to update the Tree object. updateTree can take a parameter:<ul>
<li>'file': in his case the current PYFTscope object is analyzed</li>
<li>'scan': the Tree looks for new or removed files (caution, this method is expensive)</li>
<li>'signal': some files or PYFTscope objects are analysed to update the Tree object. These files or PYFTscope objects are designed with the signal method of the Tree object.</li>
</ul>
</li>
</ul>
<p>updateVarList (defined in variables): this decorator should be used for methods that can modify the variables (existence, name, characteristics). It suppresses the cached version of the variable list (VarList instance) attached to the PYFT instance.</p><ul>
<li>noParallel (defined in util): methods decorated with it cannot be executed in parallel with other methods decorated the same way. This is used to decorate methods that introduce modifications into the tree. For this reason, the noParallel decorator <em>must appear</em> before the updateTree one.</li>
</ul>
<h3><a class="anchor" id="autotoc_md20"></a>
Coding standards</h3>
<p>Coding standards are checked using the pylint and flake8 tools. The aim is to have no messages from flake8 and to keep pylint's score above 9.8.</p>
<p>The project is written in “lower camel case” with lines of up to 100 characters. As the main class is split into several sub-classes that are not independent, it is normal for pylint to detect accesses to attributes that are not members of the classes. The pyproject.toml and .flake8 files have been adapted to take account of these specificities.</p>
<p>On top of this, the code is often complex and generates multiple “too many” branches/statements/lines/... messages, which are ignored.</p>
<p>From the project root, tests are launched by commands:</p><ul>
<li>flake8 src/pyft/ bin/pyft_*.py</li>
<li>pylint -d R0912,C0209,R0915,R1702,C0302,R0913,R0914,W1202,R0904,R0902 src/pyft/ bin/pyft_*.py</li>
</ul>
<h1><a class="anchor" id="autotoc_md21"></a>
Examples and tests</h1>
<p>The examples directory contains a script (tests.sh) that performs a non-regression test. But, this directory can also be used as a registry of transformation examples. The files *_after.F90 are obtained by transforming the *_before.F90 files using the command line options in comment at the very begining of these files. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>

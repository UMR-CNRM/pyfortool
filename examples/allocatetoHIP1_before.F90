!#PYFT transfo: --allocatetoHIP
!MNH_LIC Copyright 2013-2024 CNRS, Meteo-France and Universite Paul Sabatier
!MNH_LIC This is part of the Meso-NH software governed by the CeCILL-C licence
!MNH_LIC version 1. See LICENSE, CeCILL-C_V1-en.txt and CeCILL-C_V1-fr.txt
!MNH_LIC for details. version 1.
!-----------------------------------------------------------------
! Modifications:
!  P. Wautelet 10/07/2019: bugfix: MNH_REL_ZT3D_N0: access outside of array was possible
!  P. Wautelet 20/10/2021: create ZT1DFLAT buffer that can be used for any size and shape arrays (real)
!  P. Wautelet 31/01/2022: add new functionalities for integers, logicals and real flat pools
!  P. Wautelet 03/02/2022: manage memory with a LIFO pool
!  P. Wautelet 12/02/2024: add possibility to align memory addresses returned by MNH_MEM_GET
!-----------------------------------------------------------------

! Set MNM_MEM_ALIGN to 1 to memory align beginning of variables returned by MNH_MEM_GET
#define MNH_MEM_ALIGN 0

MODULE MODE_MNH_ZWORK

  use modd_precision,  only: MNHINT32, MNHINT64
  use modd_parameters, only: NNEGUNDEF

  use mode_msg

  USE  MODD_CONFZ, ONLY : NPMAX_T1DFLAT_R

  IMPLICIT NONE

  INTEGER, PARAMETER :: NALIGNSIZE_BIT = 4096 ! Memory alignment size (in bits)
  INTEGER, PARAMETER :: NALIGNSIZE_REAL = NALIGNSIZE_BIT / MNH_REAL ! Memory alignment size (in reals)
  INTEGER, PARAMETER :: NALIGNSIZE_INT  = NALIGNSIZE_BIT / MNH_INT  ! Memory alignment size (in integers)
  INTEGER, PARAMETER :: NALIGNSIZE_BOOL = NALIGNSIZE_BIT / MNH_INT  ! Memory alignment size (in logicals)


  INTEGER, SAVE :: IIB,IJB,IKB  ! Begining useful area in x,y,z directions
  INTEGER, SAVE :: IIE,IJE,IKE  ! End useful area in x,y,z directions

  !
  INTEGER,SAVE                    :: IJS,IJN, IIW,IIA
  !
  INTEGER, SAVE                   :: IIU,IJU,IKU,IIJKU
  LOGICAL, SAVE                   :: GWEST , GEAST
  LOGICAL, SAVE                   :: GSOUTH , GNORTH

  LOGICAL, SAVE                   :: GFIRST_CALL_MNH_ALLOC_ZWORK = .TRUE.
  !
  REAL, SAVE, ALLOCATABLE , DIMENSION(:,:)   :: ZPSRC_HALO2_WEST
  REAL, SAVE, ALLOCATABLE , DIMENSION(:,:)   :: ZPSRC_HALO2_SOUTH

  REAL, SAVE, ALLOCATABLE , DIMENSION(:,:,:) :: ZUNIT3D

  INTEGER, parameter                        :: JPMAX_T3D = 100
  INTEGER , ALLOCATABLE, DIMENSION (:)      :: NT3D_POOL
  INTEGER                                   :: NT3D_TOP , NT3D_TOP_MAX = 0
  INTEGER                                   :: NT3D_TOP_CURRENT(JPMAX_T3D+1) ,  NT3D_TOP_CURRENT_INDEX = 0
  REAL,SAVE    , ALLOCATABLE, TARGET , DIMENSION(:,:,:,:)          :: ZT3D

  REAL,SAVE    , ALLOCATABLE, TARGET , DIMENSION(:)                :: ZT1D_OSIZE
  REAL,SAVE    , ALLOCATABLE, TARGET , DIMENSION(:,:)              :: ZT2D_OSIZE
  REAL,SAVE    , ALLOCATABLE, TARGET , DIMENSION(:,:,:)            :: ZT3D_OSIZE
  REAL,SAVE    , ALLOCATABLE, TARGET , DIMENSION(:,:,:,:)          :: ZT4D_OSIZE
  

  TYPE TMODEL
      REAL    , POINTER, DIMENSION(:,:,:,:) :: X
  END TYPE TMODEL

  TYPE(TMODEL) , DIMENSION(10) :: MODEL

  INTEGER, parameter                        :: JPMAX_T3D_G = 1
  INTEGER , ALLOCATABLE, DIMENSION (:)      :: NT3D_POOL_G
  INTEGER                                   :: NT3D_TOP_G , NT3D_TOP_G_MAX = 0  
  LOGICAL,SAVE    , ALLOCATABLE, TARGET , DIMENSION(:,:,:,:)       :: GT3D
  LOGICAL,SAVE    , ALLOCATABLE, TARGET , DIMENSION(:,:)           :: GT2D_OSIZE

  INTEGER, parameter                        :: JPMAX_T3D_I = 1
  INTEGER , ALLOCATABLE, DIMENSION (:)      :: NT3D_POOL_I
  INTEGER                                   :: NT3D_TOP_I , NT3D_TOP_I_MAX = 0  
  INTEGER,SAVE    , ALLOCATABLE, TARGET , DIMENSION(:,:,:,:)       :: IT3D

  INTEGER, parameter                        :: JPMAX_T1D_R = 10
  INTEGER , ALLOCATABLE, DIMENSION (:)      :: NT1D_POOL_R
  INTEGER                                   :: NT1D_TOP_R , NT1D_TOP_R_MAX = 0  
  REAL,SAVE    , ALLOCATABLE, TARGET , DIMENSION(:,:)       :: ZT1D 
  
  INTEGER, parameter                        :: JPMAX_T1D_I = 1
  INTEGER , ALLOCATABLE, DIMENSION (:)      :: NT1D_POOL_I
  INTEGER                                   :: NT1D_TOP_I , NT1D_TOP_I_MAX = 0  
  INTEGER,SAVE    , ALLOCATABLE, TARGET , DIMENSION(:,:)       :: IT1D
  INTEGER,SAVE    , ALLOCATABLE, TARGET , DIMENSION(:)         :: IT1D_OSIZE


  INTEGER, PARAMETER :: NPOSNAMESZ = 32
  CHARACTER(LEN=NPOSNAMESZ), PARAMETER :: CPOSNAME_DEFAULT = 'NOTSET'

  TYPE :: TMNH_MEM_POS
    INTEGER :: NPOS_G = NNEGUNDEF !Position in the logical array
    INTEGER :: NPOS_I = NNEGUNDEF !Position in the integer array
    INTEGER :: NPOS_R = NNEGUNDEF !Position in the real array

    INTEGER :: NPOS_POOL_G = NNEGUNDEF !Position in the logical pool array
    INTEGER :: NPOS_POOL_I = NNEGUNDEF !Position in the integer pool array
    INTEGER :: NPOS_POOL_R = NNEGUNDEF !Position in the real pool array

    CHARACTER(LEN=NPOSNAMESZ) :: CNAME = CPOSNAME_DEFAULT
  END TYPE TMNH_MEM_POS

  INTEGER, PARAMETER                                 :: JPPOOLSTEP_FLAT = 10 !Number of elements added to the pool when too small

  INTEGER, SAVE                                      :: NMAXSIZE_POOL_POS = 20 !Initial maximum number of entries in TPOOL_POS
  TYPE(TMNH_MEM_POS), ALLOCATABLE, DIMENSION(:)      :: TPOOL_POS !Pool to store positions (LIFO way)
  INTEGER, SAVE                                      :: NPOOL_POS, NPOOL_POS_MAX = 0 !Position in the pool

  !------ Logical 1DFLAT pool
  INTEGER, PARAMETER                                 :: JPMAX_T1DFLAT_G = 10       !Used to determine max size of buffer GT1DFLAT
                                                                                   !(3D size of the mesh * JPMAX_T1DFLAT_G)
  INTEGER,                SAVE                       :: NPMAX_POOL_T1DFLAT_G = 100 !Maximum size of the pool (max number of arrays)
  INTEGER(KIND=MNHINT64), ALLOCATABLE, DIMENSION (:) :: NT1DFLAT_POOL_G   !Position in ZT1DFLAT of the beginning of each array
  INTEGER(KIND=MNHINT64), ALLOCATABLE, DIMENSION (:) :: NT1DFLAT_SIZE_G   !Size of each array
  INTEGER(KIND=MNHINT64), SAVE                       :: NT1DFLAT_MAXSIZE_G                      !Total allocated size of ZT1DFLAT
  INTEGER,                SAVE                       :: NT1DFLAT_TOP_G, NT1DFLAT_TOP_G_MAX = 0  !Position in the pool
  INTEGER(KIND=MNHINT64), SAVE                       :: NT1DFLAT_POS_G, NT1DFLAT_POS_G_MAX = 0  !Position in the array
  LOGICAl, SAVE, ALLOCATABLE, TARGET, DIMENSION(:)   :: GT1DFLAT

  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NCALL_MNH_GET_GT1DFLAT      = 0
  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NCALL_MNH_REL_GT1DFLAT      = 0
  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NCALL_MNH_ALLOCATE_GT1DFLAT = 0
  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NCALL_MNH_ALLOCATE_GT2DFLAT = 0
  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NCALL_MNH_ALLOCATE_GT3DFLAT = 0
  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NTOT_GETSIZE_GT1DFLAT       = 0 !Sum of all requested sizes in MNH_REL_GT1DFLAT
  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NTOT_GETSIZE_GT2DFLAT       = 0 !Sum of all requested sizes in MNH_REL_GT2DFLAT
  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NTOT_RELSIZE_GT1DFLAT       = 0 !Sum of all released sizes in MNH_REL_GT1DFLAT
  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NTOT_ALLOCSIZE_GT1DFLAT     = 0 !Sum of all requested sizes in MNH_ALLOCATE_GT1DFLAT
  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NTOT_ALLOCSIZE_GT2DFLAT     = 0 !Sum of all requested sizes in MNH_ALLOCATE_GT2DFLAT
  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NTOT_ALLOCSIZE_GT3DFLAT     = 0 !Sum of all requested sizes in MNH_ALLOCATE_GT3DFLAT


  !------ Integer 1DFLAT pool
  INTEGER, PARAMETER                                 :: JPMAX_T1DFLAT_I = 30       !Used to determine max size of buffer IT1DFLAT
                                                                                   !(3D size of the mesh * JPMAX_T1DFLAT_I)
  INTEGER,                SAVE                       :: NPMAX_POOL_T1DFLAT_I = 100 !Maximum size of the pool (max number of arrays)
  INTEGER(KIND=MNHINT64), ALLOCATABLE, DIMENSION (:) :: NT1DFLAT_POOL_I   !Position in ZT1DFLAT of the beginning of each array
  INTEGER(KIND=MNHINT64), ALLOCATABLE, DIMENSION (:) :: NT1DFLAT_SIZE_I   !Size of each array
  INTEGER(KIND=MNHINT64), SAVE                       :: NT1DFLAT_MAXSIZE_I                      !Total allocated size of ZT1DFLAT
  INTEGER,                SAVE                       :: NT1DFLAT_TOP_I, NT1DFLAT_TOP_I_MAX = 0  !Position in the pool
  INTEGER(KIND=MNHINT64), SAVE                       :: NT1DFLAT_POS_I, NT1DFLAT_POS_I_MAX = 0  !Position in the array
  INTEGER, SAVE, ALLOCATABLE, TARGET, DIMENSION(:)   :: IT1DFLAT

  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NCALL_MNH_GET_IT1DFLAT      = 0
  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NCALL_MNH_REL_IT1DFLAT      = 0
  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NCALL_MNH_ALLOCATE_IT1DFLAT = 0
  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NCALL_MNH_ALLOCATE_IT2DFLAT = 0
  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NCALL_MNH_ALLOCATE_IT3DFLAT = 0
  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NTOT_GETSIZE_IT1DFLAT       = 0 !Sum of all requested sizes in MNH_REL_IT1DFLAT
  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NTOT_GETSIZE_IT2DFLAT       = 0 !Sum of all requested sizes in MNH_REL_IT2DFLAT
  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NTOT_RELSIZE_IT1DFLAT       = 0 !Sum of all released sizes in MNH_REL_IT1DFLAT
  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NTOT_ALLOCSIZE_IT1DFLAT     = 0 !Sum of all requested sizes in MNH_ALLOCATE_IT1DFLAT
  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NTOT_ALLOCSIZE_IT2DFLAT     = 0 !Sum of all requested sizes in MNH_ALLOCATE_IT2DFLAT
  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NTOT_ALLOCSIZE_IT3DFLAT     = 0 !Sum of all requested sizes in MNH_ALLOCATE_IT3DFLAT


!------ Real 1DFLAT pool
!!$  INTEGER,                SAVE                       :: NPMAX_T1DFLAT_R = 300      !Used to determine max size of buffer ZT1DFLAT
!!$                                                                                   !(3D size of the mesh * NPMAX_T1DFLAT_R)
  INTEGER,                SAVE                       :: NPMAX_POOL_T1DFLAT_R = 250 !Maximum size of the pool (max number of arrays)
  INTEGER(KIND=MNHINT64), ALLOCATABLE, DIMENSION (:) :: NT1DFLAT_POOL_R   !Position in ZT1DFLAT of the beginning of each array
  INTEGER(KIND=MNHINT64), ALLOCATABLE, DIMENSION (:) :: NT1DFLAT_SIZE_R   !Size of each array
  INTEGER(KIND=MNHINT64), SAVE                       :: NT1DFLAT_MAXSIZE_R                      !Total allocated size of ZT1DFLAT
  INTEGER,                SAVE                       :: NT1DFLAT_TOP_R, NT1DFLAT_TOP_R_MAX = 0  !Position in the pool
  INTEGER(KIND=MNHINT64), SAVE                       :: NT1DFLAT_POS_R, NT1DFLAT_POS_R_MAX = 0  !Position in the array
  REAL, SAVE, ALLOCATABLE, TARGET, DIMENSION(:)      :: ZT1DFLAT

  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NCALL_MNH_GET_ZT1DFLAT      = 0
  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NCALL_MNH_REL_ZT1DFLAT      = 0
  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NCALL_MNH_ALLOCATE_ZT1DFLAT = 0
  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NCALL_MNH_ALLOCATE_ZT2DFLAT = 0
  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NCALL_MNH_ALLOCATE_ZT3DFLAT = 0
  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NCALL_MNH_ALLOCATE_ZT4DFLAT = 0
  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NCALL_MNH_MEM_POSITION_PIN  = 0
  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NCALL_MNH_MEM_RELEASE       = 0
  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NTOT_GETSIZE_ZT1DFLAT       = 0 !Sum of all requested sizes in MNH_REL_ZT1DFLAT
  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NTOT_RELSIZE_ZT1DFLAT       = 0 !Sum of all released sizes in MNH_REL_ZT1DFLAT
  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NTOT_ALLOCSIZE_ZT1DFLAT     = 0 !Sum of all requested sizes in MNH_ALLOCATE_ZT1DFLAT
  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NTOT_ALLOCSIZE_ZT2DFLAT     = 0 !Sum of all requested sizes in MNH_ALLOCATE_ZT1DFLAT
  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NTOT_ALLOCSIZE_ZT3DFLAT     = 0 !Sum of all requested sizes in MNH_ALLOCATE_ZT3DFLAT
  INTEGER(KIND=MNHINT64), PRIVATE, SAVE :: NTOT_ALLOCSIZE_ZT4DFLAT     = 0 !Sum of all requested sizes in MNH_ALLOCATE_ZT4DFLAT


  INTERFACE MNH_MEM_GET
    MODULE PROCEDURE :: MNH_ALLOCATE_GT1DFLAT_INT32
    MODULE PROCEDURE :: MNH_ALLOCATE_GT1DFLAT_INT64
    MODULE PROCEDURE :: MNH_ALLOCATE_GT1DFLAT_SIZE_INT32
    MODULE PROCEDURE :: MNH_ALLOCATE_GT1DFLAT_SIZE_INT64
    MODULE PROCEDURE :: MNH_ALLOCATE_GT2DFLAT
    MODULE PROCEDURE :: MNH_ALLOCATE_GT2DFLAT_SIZE
    MODULE PROCEDURE :: MNH_ALLOCATE_GT3DFLAT
    MODULE PROCEDURE :: MNH_ALLOCATE_GT3DFLAT_SIZE
    MODULE PROCEDURE :: MNH_ALLOCATE_IT1DFLAT_INT32
    MODULE PROCEDURE :: MNH_ALLOCATE_IT1DFLAT_INT64
    MODULE PROCEDURE :: MNH_ALLOCATE_IT1DFLAT_SIZE_INT32
    MODULE PROCEDURE :: MNH_ALLOCATE_IT1DFLAT_SIZE_INT64
    MODULE PROCEDURE :: MNH_ALLOCATE_IT2DFLAT
    MODULE PROCEDURE :: MNH_ALLOCATE_IT2DFLAT_SIZE
    MODULE PROCEDURE :: MNH_ALLOCATE_IT3DFLAT
    MODULE PROCEDURE :: MNH_ALLOCATE_IT3DFLAT_SIZE
    MODULE PROCEDURE :: MNH_ALLOCATE_ZT1DFLAT_INT32
    MODULE PROCEDURE :: MNH_ALLOCATE_ZT1DFLAT_INT64
    MODULE PROCEDURE :: MNH_ALLOCATE_ZT1DFLAT_SIZE_INT32
    MODULE PROCEDURE :: MNH_ALLOCATE_ZT1DFLAT_SIZE_INT64
    MODULE PROCEDURE :: MNH_ALLOCATE_ZT2DFLAT
    MODULE PROCEDURE :: MNH_ALLOCATE_ZT2DFLAT_SIZE
    MODULE PROCEDURE :: MNH_ALLOCATE_ZT3DFLAT
    MODULE PROCEDURE :: MNH_ALLOCATE_ZT3DFLAT_SIZE
    MODULE PROCEDURE :: MNH_ALLOCATE_ZT4DFLAT
    MODULE PROCEDURE :: MNH_ALLOCATE_ZT4DFLAT_SIZE
  END INTERFACE MNH_MEM_GET

CONTAINS

  SUBROUTINE MNH_ALLOC_ZWORK(KMODEL)

    USE MODE_TOOLS_ll,   ONLY: GET_DIM_EXT_ll, GET_INDICE_ll, LWEST_ll, LEAST_ll, LSOUTH_ll, LNORTH_ll

    USE MODD_PARAMETERS, ONLY: JPVEXT, NNEGUNDEF, XUNDEF
    USE MODD_DIM_n,      ONLY: NKMAX

    IMPLICIT NONE

    INTEGER, INTENT(IN) :: KMODEL

    INTEGER :: JI

    IF (GFIRST_CALL_MNH_ALLOC_ZWORK) THEN
       GFIRST_CALL_MNH_ALLOC_ZWORK = .FALSE.
       !
       ! Array dim
       !
       CALL GET_DIM_EXT_ll('B',IIU,IJU)     
       IKU=NKMAX + 2* JPVEXT
       IIJKU = IIU*IJU*IKU
       !
       ! Computation bound
       !
       CALL GET_INDICE_ll(IIB,IJB,IIE,IJE)
       IJS=IJB
       IJN=IJE
       IIW=IIB
       IIA=IIE
       IKB = 1     + JPVEXT
       IKE = NKMAX + JPVEXT
       !
       ! Lateral boundary
       !
       GWEST = LWEST_ll()
       GEAST = LEAST_ll()

       GSOUTH=LSOUTH_ll()
       GNORTH=LNORTH_ll()

       !
       ! Work array
       ! 
       ALLOCATE (ZPSRC_HALO2_WEST(IJU,IKU)) 
       ALLOCATE (ZPSRC_HALO2_SOUTH(IIU,IKU)) 
       !$acc enter data create(ZPSRC_HALO2_WEST,ZPSRC_HALO2_SOUTH)

       ALLOCATE (ZUNIT3D(IIU,IJU,IKU))
       !$acc enter data create(ZUNIT3D)

!----- Real pool
       
       !ALLOCATE (ZT3D_A1(IIU,IJU,IKU,JPMAX_T3D))
       !MODEL(1)%X => ZT3D_A1
       !ZT3D => MODEL(1)%X
       ALLOCATE (ZT3D(IIU,IJU,IKU,JPMAX_T3D))
       !$acc enter data create(ZT3D)

       ALLOCATE (ZT1D_OSIZE(0))
       ALLOCATE (ZT2D_OSIZE(IIU,0))
       ALLOCATE (ZT3D_OSIZE(IIU,IJU,0))
       ALLOCATE (ZT4D_OSIZE(IIU,IJU,IKU,0))
       !$acc enter data create(ZT1D_OSIZE,ZT2D_OSIZE,ZT3D_OSIZE,ZT4D_OSIZE)      

       ALLOCATE (NT3D_POOL(JPMAX_T3D))
       NT3D_TOP = 0
       DO JI = 1, JPMAX_T3D
          NT3D_POOL(JI) = JI
       END DO

!------ Logical pool
       
       ALLOCATE (GT3D(IIU,IJU,IKU,JPMAX_T3D_G))
       !$acc enter data create(GT3D)

       ALLOCATE (GT2D_OSIZE(IIU,0))
       !$acc enter data create(GT2D_OSIZE)

       ALLOCATE (NT3D_POOL_G(JPMAX_T3D_G))
       NT3D_TOP_G = 0
       DO JI = 1, JPMAX_T3D_G
          NT3D_POOL_G(JI) = JI
       END DO

!------ Integer pool
       
       ALLOCATE (IT3D(IIU,IJU,IKU,JPMAX_T3D_I))
       !$acc enter data create(IT3D)

       ALLOCATE (NT3D_POOL_I(JPMAX_T3D_I))
       NT3D_TOP_I = 0
       DO JI = 1, JPMAX_T3D_I
          NT3D_POOL_I(JI) = JI
       END DO

!------ Real 1D pool 
       
       ALLOCATE (ZT1D(IIU*IJU*IKU,JPMAX_T1D_R))
       !$acc enter data create(ZT1D)

       ALLOCATE (NT1D_POOL_R(JPMAX_T1D_R))
       NT1D_TOP_R = 0
       DO JI = 1, JPMAX_T1D_R
          NT1D_POOL_R(JI) = JI
       END DO

!------ Integer 1D pool
       
       ALLOCATE (IT1D(IIU*IJU*IKU,JPMAX_T1D_I))
       ALLOCATE (IT1D_OSIZE(0))
       !$acc enter data create(IT1D,IT1D_OSIZE)

       ALLOCATE (NT1D_POOL_I(JPMAX_T1D_I))
       NT1D_TOP_I = 0
       DO JI = 1, JPMAX_T1D_I
          NT1D_POOL_I(JI) = JI
       END DO       
       

       ALLOCATE( TPOOL_POS(NMAXSIZE_POOL_POS) )

!------ Logical 1DFLAT pool

       NT1DFLAT_MAXSIZE_G = INT( IIU, KIND=MNHINT64 ) * IJU * IKU * JPMAX_T1DFLAT_G
       ALLOCATE( GT1DFLAT(NT1DFLAT_MAXSIZE_G) )
       !$acc enter data create( GT1DFLAT )

       ALLOCATE( NT1DFLAT_POOL_G(NPMAX_POOL_T1DFLAT_G) )
       ALLOCATE( NT1DFLAT_SIZE_G(NPMAX_POOL_T1DFLAT_G) )
       NT1DFLAT_POOL_G(:) = NNEGUNDEF
       NT1DFLAT_SIZE_G(:) = NNEGUNDEF
       NT1DFLAT_TOP_G = 0

!------ Integer 1DFLAT pool

       NT1DFLAT_MAXSIZE_I = INT( IIU, KIND=MNHINT64 ) * IJU * IKU * JPMAX_T1DFLAT_I
       ALLOCATE( IT1DFLAT(NT1DFLAT_MAXSIZE_I) )
       !$acc enter data create( IT1DFLAT )

       ALLOCATE( NT1DFLAT_POOL_I(NPMAX_POOL_T1DFLAT_I) )
       ALLOCATE( NT1DFLAT_SIZE_I(NPMAX_POOL_T1DFLAT_I) )
       NT1DFLAT_POOL_I(:) = NNEGUNDEF
       NT1DFLAT_SIZE_I(:) = NNEGUNDEF
       NT1DFLAT_TOP_I = 0

!------ Real 1DFLAT pool

       NT1DFLAT_MAXSIZE_R = INT( IIU, KIND=MNHINT64 ) * IJU * IKU * NPMAX_T1DFLAT_R
       ALLOCATE( ZT1DFLAT(NT1DFLAT_MAXSIZE_R) )
       !$acc enter data create( ZT1DFLAT )

       ALLOCATE( NT1DFLAT_POOL_R(NPMAX_POOL_T1DFLAT_R) )
       ALLOCATE( NT1DFLAT_SIZE_R(NPMAX_POOL_T1DFLAT_R) )
       NT1DFLAT_POOL_R(:) = NNEGUNDEF
       NT1DFLAT_SIZE_R(:) = NNEGUNDEF
       NT1DFLAT_TOP_R = 0

!------ Default values
       
       !$acc kernels present(ZPSRC_HALO2_WEST,ZPSRC_HALO2_SOUTH,ZUNIT3D,ZT3D, &
       !$acc &  ZT1D,ZT1DFLAT,IT3D,IT1D,GT3D,GT1DFLAT)

       ZPSRC_HALO2_WEST(:,:) = XUNDEF
       ZPSRC_HALO2_SOUTH(:,:) = XUNDEF
       
       ZUNIT3D(:,:,:) = 1.0

       ZT3D(:,:,:,:)  = XUNDEF
       ZT1D(:,:)      = XUNDEF
       ZT1DFLAT(:)    = XUNDEF

       IT3D(:,:,:,:)  = 0.0
       IT1D(:,:)  = 0.0
       
       GT3D(:,:,:,:) = .FALSE.
       GT1DFLAT(:)   = .FALSE.

       !$acc end kernels

       !$acc update host (ZPSRC_HALO2_WEST,ZPSRC_HALO2_SOUTH)
       !$acc update host (ZUNIT3D)
       !$acc update host (ZT3D,ZT1D,ZT1DFLAT)
       !$acc update host (IT3D, IT1D)
       !$acc update host (GT3D, GT1DFLAT)

    END IF

  END SUBROUTINE MNH_ALLOC_ZWORK

  SUBROUTINE MNH_GET_ZT3D_N0(KTEMP)

    IMPLICIT NONE

    INTEGER :: KTEMP

    IF (NT3D_TOP == JPMAX_T3D ) THEN
      WRITE( *, '( " MNH_GET_ZT3D_N0: NT3D_TOP too big (increaze JPMAX_T3D) , NT3D_TOP=",I4 )' ) NT3D_TOP
      call Print_msg( NVERB_FATAL, 'GEN', 'MNH_GET_ZT3D_N0', 'NT3D_TOP too big (increaze JPMAX_T3D)' )
    ELSE
       NT3D_TOP = NT3D_TOP + 1
       KTEMP = NT3D_POOL(NT3D_TOP)
       NT3D_POOL(NT3D_TOP) = - KTEMP
       IF (  NT3D_TOP > NT3D_TOP_MAX ) THEN
          NT3D_TOP_MAX = NT3D_TOP
          !WRITE( *, '( " MNH_GET_ZT3D: NT3D_TOP_MAX=",I4," KTEMP=",I4 )' ) NT3D_TOP_MAX,KTEMP
       END IF
    ENDIF
    !WRITE( *, '( "MNH_GET_ZT3D: reserving ZT3D (",I4,")" )' ) KTEMP

  END SUBROUTINE MNH_GET_ZT3D_N0

  SUBROUTINE MNH_GET_ZT3D(KTEMP1,KTEMP2,KTEMP3,KTEMP4,KTEMP5,KTEMP6,KTEMP7,KTEMP8,KTEMP9, &
                          KTEMP10,KTEMP11,KTEMP12,KTEMP13,KTEMP14,KTEMP15,KTEMP16,KTEMP17,KTEMP18)

    IMPLICIT NONE

    INTEGER          :: KTEMP1
    INTEGER,OPTIONAL :: KTEMP2,KTEMP3,KTEMP4,KTEMP5,KTEMP6,KTEMP7,KTEMP8,KTEMP9
    INTEGER,OPTIONAL :: KTEMP10,KTEMP11,KTEMP12,KTEMP13,KTEMP14,KTEMP15,KTEMP16,KTEMP17,KTEMP18

                          CALL MNH_GET_ZT3D_N0(KTEMP1)
    IF (PRESENT(KTEMP2))  CALL MNH_GET_ZT3D_N0(KTEMP2)
    IF (PRESENT(KTEMP3))  CALL MNH_GET_ZT3D_N0(KTEMP3)
    IF (PRESENT(KTEMP4))  CALL MNH_GET_ZT3D_N0(KTEMP4)
    IF (PRESENT(KTEMP5))  CALL MNH_GET_ZT3D_N0(KTEMP5)
    IF (PRESENT(KTEMP6))  CALL MNH_GET_ZT3D_N0(KTEMP6)
    IF (PRESENT(KTEMP7))  CALL MNH_GET_ZT3D_N0(KTEMP7)
    IF (PRESENT(KTEMP8))  CALL MNH_GET_ZT3D_N0(KTEMP8)
    IF (PRESENT(KTEMP9))  CALL MNH_GET_ZT3D_N0(KTEMP9)
    IF (PRESENT(KTEMP10)) CALL MNH_GET_ZT3D_N0(KTEMP10)
    IF (PRESENT(KTEMP11)) CALL MNH_GET_ZT3D_N0(KTEMP11)
    IF (PRESENT(KTEMP12)) CALL MNH_GET_ZT3D_N0(KTEMP12)
    IF (PRESENT(KTEMP13)) CALL MNH_GET_ZT3D_N0(KTEMP13)
    IF (PRESENT(KTEMP14)) CALL MNH_GET_ZT3D_N0(KTEMP14)
    IF (PRESENT(KTEMP15)) CALL MNH_GET_ZT3D_N0(KTEMP15)
    IF (PRESENT(KTEMP16)) CALL MNH_GET_ZT3D_N0(KTEMP16)
    IF (PRESENT(KTEMP17)) CALL MNH_GET_ZT3D_N0(KTEMP17)
    IF (PRESENT(KTEMP18)) CALL MNH_GET_ZT3D_N0(KTEMP18)

  END SUBROUTINE MNH_GET_ZT3D

  SUBROUTINE MNH_GET_ZT4D(KSIZE,KBEG,KEND)

    IMPLICIT NONE

    INTEGER, INTENT(IN) :: KSIZE
    INTEGER, INTENT(OUT) :: KBEG, KEND

    INTEGER :: JI

    IF (NT3D_TOP + KSIZE > JPMAX_T3D ) THEN
      WRITE( *, '( " MNH_GET_ZT4D: NT3D_TOP+KSIZE too big (increaze JPMAX_T3D) , NT3D_TOP=",I4 )' ) NT3D_TOP+KSIZE
      call Print_msg( NVERB_FATAL, 'GEN', 'MNH_GET_ZT4D', 'NT3D_TOP+ KSIZE too big (increaze JPMAX_T3D)' )
    ELSE
       KBEG = NT3D_TOP + 1
       KEND = NT3D_TOP + KSIZE
       NT3D_TOP = NT3D_TOP + KSIZE
       DO JI = KBEG, KEND
         IF (NT3D_POOL(JI) <= 0 ) THEN           
           call Print_msg( NVERB_FATAL, 'GEN', 'MNH_GET_ZT4D', 'trying to use area already reserved' )
         END IF
         NT3D_POOL(JI) = -JI
       END DO
       IF ( NT3D_TOP > NT3D_TOP_MAX ) THEN
          NT3D_TOP_MAX = NT3D_TOP
          WRITE( *, '( " MNH_GET_ZT4D: NT3D_TOP_MAX=",I4," KBEG=",I4," KEND=",I4 )' ) NT3D_TOP_MAX,KBEG,KEND
       END IF
    ENDIF
    !WRITE( *, '( "MNH_GET_ZT4D: reserving ZT3D (",I4,I4,")" )' ) KBEG,KEND

  END SUBROUTINE MNH_GET_ZT4D

  SUBROUTINE MNH_REL_ZT3D_N0(KTEMP)

    IMPLICIT NONE

    INTEGER :: KTEMP

    IF ( KTEMP .EQ. 0 ) THEN
       ! Special case Zero size array do nothing
       RETURN
    ELSE
    
    IF ( ( NT3D_TOP > JPMAX_T3D ) .OR. ( NT3D_TOP < 1 ) ) THEN
      call Print_msg( NVERB_FATAL, 'GEN', 'MNH_REL_ZT3D_N0', 'invalid value for NT3D_TOP' )
    ELSE
      NT3D_POOL(KTEMP) = KTEMP
      IF (KTEMP == NT3D_TOP) THEN
        NT3D_TOP = NT3D_TOP - 1
     ELSE
        WRITE( *, '( "MNH_REL_ZT3D: releasing ZT3D (",2I8,")" )' ) KTEMP, NT3D_TOP
        call Print_msg( NVERB_FATAL, 'GEN', 'MNH_REL_ZT3D_N0', 'invalid value for KTEMP <> NT3D_TOP' )
      END IF
    ENDIF
    !WRITE( *, '( "MNH_REL_ZT3D: releasing ZT3D (",I4,")" )' ) KTEMP
    ENDIF

  END SUBROUTINE MNH_REL_ZT3D_N0

  SUBROUTINE MNH_REL_ZT3D(KTEMP1,KTEMP2,KTEMP3,KTEMP4,KTEMP5,KTEMP6,KTEMP7,KTEMP8,KTEMP9, &
                          KTEMP10,KTEMP11,KTEMP12,KTEMP13,KTEMP14,KTEMP15,KTEMP16,KTEMP17,KTEMP18, &
                          KTEMP19,KTEMP20)

    IMPLICIT NONE

    INTEGER          :: KTEMP1
    INTEGER,OPTIONAL :: KTEMP2,KTEMP3,KTEMP4,KTEMP5,KTEMP6,KTEMP7,KTEMP8,KTEMP9
    INTEGER,OPTIONAL :: KTEMP10,KTEMP11,KTEMP12,KTEMP13,KTEMP14,KTEMP15,KTEMP16,KTEMP17,KTEMP18
    INTEGER,OPTIONAL :: KTEMP19,KTEMP20

    IF (PRESENT(KTEMP20)) CALL MNH_REL_ZT3D_N0(KTEMP20)
    IF (PRESENT(KTEMP19)) CALL MNH_REL_ZT3D_N0(KTEMP19)
    IF (PRESENT(KTEMP18)) CALL MNH_REL_ZT3D_N0(KTEMP18)
    IF (PRESENT(KTEMP17)) CALL MNH_REL_ZT3D_N0(KTEMP17)
    IF (PRESENT(KTEMP16)) CALL MNH_REL_ZT3D_N0(KTEMP16)
    IF (PRESENT(KTEMP15)) CALL MNH_REL_ZT3D_N0(KTEMP15)
    IF (PRESENT(KTEMP14)) CALL MNH_REL_ZT3D_N0(KTEMP14)
    IF (PRESENT(KTEMP13)) CALL MNH_REL_ZT3D_N0(KTEMP13)
    IF (PRESENT(KTEMP12)) CALL MNH_REL_ZT3D_N0(KTEMP12)
    IF (PRESENT(KTEMP11)) CALL MNH_REL_ZT3D_N0(KTEMP11)
    IF (PRESENT(KTEMP10)) CALL MNH_REL_ZT3D_N0(KTEMP10)
    IF (PRESENT(KTEMP9))  CALL MNH_REL_ZT3D_N0(KTEMP9)
    IF (PRESENT(KTEMP8))  CALL MNH_REL_ZT3D_N0(KTEMP8)
    IF (PRESENT(KTEMP7))  CALL MNH_REL_ZT3D_N0(KTEMP7)
    IF (PRESENT(KTEMP6))  CALL MNH_REL_ZT3D_N0(KTEMP6)
    IF (PRESENT(KTEMP5))  CALL MNH_REL_ZT3D_N0(KTEMP5)
    IF (PRESENT(KTEMP4))  CALL MNH_REL_ZT3D_N0(KTEMP4)
    IF (PRESENT(KTEMP3))  CALL MNH_REL_ZT3D_N0(KTEMP3)
    IF (PRESENT(KTEMP2))  CALL MNH_REL_ZT3D_N0(KTEMP2)
                          CALL MNH_REL_ZT3D_N0(KTEMP1)
    
  END SUBROUTINE MNH_REL_ZT3D

  SUBROUTINE MNH_REL_ZT4D(KSIZE,KBEG)

    IMPLICIT NONE

    INTEGER, INTENT(IN) :: KSIZE
    INTEGER, INTENT(IN) :: KBEG

    character(len=16) :: ytxt1, ytxt2
    INTEGER :: JI

    IF ( KSIZE .EQ. 0 ) THEN
       ! special case of O zero 4D array => ZT4D_OSIZE
       RETURN
    END IF
    IF ( KBEG + KSIZE -1 /= NT3D_TOP ) THEN
      write( ytxt1, '( I4, "-", I4 )' ) kbeg, kbeg + ksize - 1
      write( ytxt2, '( I4 )' )          NT3D_TOP
      call Print_msg( NVERB_ERROR, 'GEN', 'MNH_REL_ZT4D', 'trying to free area (' // trim( ytxt1 ) // &
                                                          ') not at the end of range (' // trim( ytxt2 ) // ')' )
    END IF
    IF ( ( KBEG + KSIZE > JPMAX_T3D ) .OR. ( KBEG < 1 ) ) THEN
      call Print_msg( NVERB_FATAL, 'GEN', 'MNH_REL_ZT4D', 'out of range' )
    END IF

    DO JI = KBEG, KBEG+KSIZE-1
       IF (NT3D_POOL(JI) /= - JI ) THEN        
          call Print_msg( NVERB_ERROR, 'GEN', 'MNH_REL_ZT4D', 'trying to free area not reserved' )
       ELSE
          NT3D_POOL(JI) = JI
      END IF
    END DO
    NT3D_TOP = NT3D_TOP - KSIZE
    !WRITE( *, '( "MNH_REL_ZT4D: releasing ZT3D (",I4,I4,")" )' ) KBEG,KBEG+KSIZE-1

  END SUBROUTINE MNH_REL_ZT4D

  FUNCTION MNH_ALLOCATE_ZT3D(PTAB,KI,KJ,KK) RESULT (KINDEX)
    
    REAL, POINTER, CONTIGUOUS , DIMENSION(:,:,:), INTENT(INOUT) :: PTAB
    INTEGER , INTENT(IN)    :: KI,KJ,KK
    INTEGER                 :: KINDEX

    !local
    IF ( KI == 0 .OR. KJ == 0 ) THEN
       CALL MNH_GET_ZT3D_N0(KINDEX)
       PTAB => ZT3D_OSIZE
    ELSE IF ( (KI .EQ. IIU) .AND. (KJ .EQ. IJU) ) THEN
       CALL MNH_GET_ZT3D_N0(KINDEX)
       IF       (KK .LE. IKU)  THEN           
          PTAB => ZT3D(:,:,1:KK,KINDEX)
       ELSE IF (KK .EQ.0 )  THEN
          PTAB => ZT3D_OSIZE
       ELSE
          call Print_msg( NVERB_ERROR, 'GEN', 'MNH_ALLOCATE_ZT3D', ' Size mismatch ' )
       END IF
    ELSE
       call Print_msg( NVERB_ERROR, 'GEN', 'MNH_ALLOCATE_ZT3D', ' Size mismatch ' )
    END IF
       
  END FUNCTION MNH_ALLOCATE_ZT3D

    FUNCTION MNH_ALLOCATE_ZT4D(PTAB,KI,KJ,KK,KL) RESULT (KINDEX_BEG)
    
    REAL, POINTER, CONTIGUOUS , DIMENSION(:,:,:,:), INTENT(INOUT) :: PTAB
    INTEGER , INTENT(IN)    :: KI,KJ,KK,KL
    INTEGER                 :: KINDEX_BEG

    !local

    INTEGER                 :: KINDEX_END

    IF ( KI == 0 .OR. KJ == 0 .OR. KK == 0 ) THEN
       PTAB => ZT4D_OSIZE
       KINDEX_BEG = 0
    ELSE IF ( (KI .EQ. IIU) .AND. (KJ .EQ. IJU) .AND. (KK .EQ. IKU) ) THEN
       IF ( KL .GE. 1 ) THEN
          CALL MNH_GET_ZT4D(KL,KINDEX_BEG,KINDEX_END)
          PTAB => ZT3D(:,:,:,KINDEX_BEG:KINDEX_END)
       ELSE
          PTAB => ZT4D_OSIZE
          KINDEX_BEG = 0
       END IF
    ELSE
       call Print_msg( NVERB_ERROR, 'GEN', 'MNH_ALLOCATE_ZT4D', ' Size mismatch ' )
    END IF
       
  END FUNCTION MNH_ALLOCATE_ZT4D

  FUNCTION MNH_ALLOCATE_ZT2D(PTAB,KI,KJ) RESULT (KINDEX)
    
    REAL, POINTER, CONTIGUOUS , DIMENSION(:,:), INTENT(INOUT) :: PTAB
    INTEGER , INTENT(IN)    :: KI,KJ
    INTEGER                 :: KINDEX

    !local

    IF (KI .EQ. IIU) THEN
       CALL MNH_GET_ZT3D_N0(KINDEX)
       IF (KJ .EQ. IJU) THEN 
          PTAB => ZT3D(:,:,1,KINDEX)
       ELSE IF (KJ .EQ. 0)  THEN
          PTAB => ZT2D_OSIZE
       ELSE
          call Print_msg( NVERB_ERROR, 'GEN', 'MNH_ALLOCATE_ZT2D', ' Size mismatch ' )
       END IF
    ELSE
       call Print_msg( NVERB_ERROR, 'GEN', 'MNH_ALLOCATE_ZT2D', ' Size mismatch ' )
    END IF
       
  END FUNCTION MNH_ALLOCATE_ZT2D

  FUNCTION MNH_ALLOCATE_ZT3DP(PTAB,KI,KJ,KKB,KKE) RESULT (KINDEX)
    
    REAL, POINTER, CONTIGUOUS , DIMENSION(:,:,:), INTENT(INOUT) :: PTAB
    INTEGER , INTENT(IN)    :: KI,KJ,KKB,KKE
    INTEGER                 :: KINDEX

    !local

    IF ( (KI .EQ. IIU) .AND. (KJ .EQ. IJU) .AND. (KKB .LE. IKU) .AND. (KKE .LE. IKU) ) THEN
       CALL MNH_GET_ZT3D_N0(KINDEX)
       PTAB(1:,1:,KKB:) => ZT3D(:,:,KKB:KKE,KINDEX)
    ELSE
       call Print_msg( NVERB_ERROR, 'GEN', 'MNH_ALLOCATE_ZT3DP', ' Size mismatch ' )
    END IF
       
  END FUNCTION MNH_ALLOCATE_ZT3DP

!-------- Logical Pool Managment
  
    SUBROUTINE MNH_GET_GT3D_N0(KTEMP)

    IMPLICIT NONE

    INTEGER :: KTEMP

    IF (NT3D_TOP_G == JPMAX_T3D_G ) THEN
      WRITE( *, '( " MNH_GET_GT3D_N0: NT3D_TOP_G too big (increaze JPMAX_T3D_G) , NT3D_TOP_G=",I4 )' ) NT3D_TOP_G
      call Print_msg( NVERB_FATAL, 'GEN', 'MNH_GET_GT3D_N0', 'NT3D_TOP_G too big (increaze JPMAX_T3D_G)' )
    ELSE
       NT3D_TOP_G = NT3D_TOP_G + 1
       KTEMP = NT3D_POOL_G(NT3D_TOP_G)
       NT3D_POOL_G(NT3D_TOP_G) = - KTEMP
       IF (  NT3D_TOP_G > NT3D_TOP_G_MAX ) THEN
          NT3D_TOP_G_MAX = NT3D_TOP_G
          !WRITE( *, '( " MNH_GET_GT3D: NT3D_TOP_G_MAX=",I4," KTEMP=",I4 )' ) NT3D_TOP_G_MAX,KTEMP
       END IF
    ENDIF
    !WRITE( *, '( "MNH_GET_GT3D: reserving GT3D (",I4,")" )' ) KTEMP

  END SUBROUTINE MNH_GET_GT3D_N0

  SUBROUTINE MNH_GET_GT3D(KTEMP1,KTEMP2,KTEMP3,KTEMP4,KTEMP5,KTEMP6,KTEMP7,KTEMP8,KTEMP9, &
                          KTEMP10,KTEMP11,KTEMP12,KTEMP13,KTEMP14,KTEMP15,KTEMP16,KTEMP17,KTEMP18)

    IMPLICIT NONE

    INTEGER          :: KTEMP1
    INTEGER,OPTIONAL :: KTEMP2,KTEMP3,KTEMP4,KTEMP5,KTEMP6,KTEMP7,KTEMP8,KTEMP9
    INTEGER,OPTIONAL :: KTEMP10,KTEMP11,KTEMP12,KTEMP13,KTEMP14,KTEMP15,KTEMP16,KTEMP17,KTEMP18

                          CALL MNH_GET_GT3D_N0(KTEMP1)
    IF (PRESENT(KTEMP2))  CALL MNH_GET_GT3D_N0(KTEMP2)
    IF (PRESENT(KTEMP3))  CALL MNH_GET_GT3D_N0(KTEMP3)
    IF (PRESENT(KTEMP4))  CALL MNH_GET_GT3D_N0(KTEMP4)
    IF (PRESENT(KTEMP5))  CALL MNH_GET_GT3D_N0(KTEMP5)
    IF (PRESENT(KTEMP6))  CALL MNH_GET_GT3D_N0(KTEMP6)
    IF (PRESENT(KTEMP7))  CALL MNH_GET_GT3D_N0(KTEMP7)
    IF (PRESENT(KTEMP8))  CALL MNH_GET_GT3D_N0(KTEMP8)
    IF (PRESENT(KTEMP9))  CALL MNH_GET_GT3D_N0(KTEMP9)
    IF (PRESENT(KTEMP10)) CALL MNH_GET_GT3D_N0(KTEMP10)
    IF (PRESENT(KTEMP11)) CALL MNH_GET_GT3D_N0(KTEMP11)
    IF (PRESENT(KTEMP12)) CALL MNH_GET_GT3D_N0(KTEMP12)
    IF (PRESENT(KTEMP13)) CALL MNH_GET_GT3D_N0(KTEMP13)
    IF (PRESENT(KTEMP14)) CALL MNH_GET_GT3D_N0(KTEMP14)
    IF (PRESENT(KTEMP15)) CALL MNH_GET_GT3D_N0(KTEMP15)
    IF (PRESENT(KTEMP16)) CALL MNH_GET_GT3D_N0(KTEMP16)
    IF (PRESENT(KTEMP17)) CALL MNH_GET_GT3D_N0(KTEMP17)
    IF (PRESENT(KTEMP18)) CALL MNH_GET_GT3D_N0(KTEMP18)

  END SUBROUTINE MNH_GET_GT3D

    SUBROUTINE MNH_REL_GT3D_N0(KTEMP)

    IMPLICIT NONE

    INTEGER :: KTEMP

    IF ( ( NT3D_TOP_G > JPMAX_T3D_G ) .OR. ( NT3D_TOP_G < 1 ) ) THEN
      call Print_msg( NVERB_FATAL, 'GEN', 'MNH_REL_GT3D_N0', 'invalid value for NT3D_TOP_G' )
    ELSE
      NT3D_POOL_G(KTEMP) = KTEMP
      IF (KTEMP == NT3D_TOP_G) THEN
        NT3D_TOP_G = NT3D_TOP_G - 1
     ELSE
        WRITE( *, '( "MNH_REL_GT3D: releasing GT3D (",2I8,")" )' ) KTEMP, NT3D_TOP_G
        call Print_msg( NVERB_FATAL, 'GEN', 'MNH_REL_GT3D_N0', 'invalid value for KTEMP <> NT3D_TOP_G' )
      END IF
    ENDIF
    !WRITE( *, '( "MNH_REL_GT3D: releasing GT3D (",I4,")" )' ) KTEMP

  END SUBROUTINE MNH_REL_GT3D_N0

  SUBROUTINE MNH_REL_GT3D(KTEMP1,KTEMP2,KTEMP3,KTEMP4,KTEMP5,KTEMP6,KTEMP7,KTEMP8,KTEMP9, &
                          KTEMP10,KTEMP11,KTEMP12,KTEMP13,KTEMP14,KTEMP15,KTEMP16,KTEMP17,KTEMP18, &
                          KTEMP19,KTEMP20)

    IMPLICIT NONE

    INTEGER          :: KTEMP1
    INTEGER,OPTIONAL :: KTEMP2,KTEMP3,KTEMP4,KTEMP5,KTEMP6,KTEMP7,KTEMP8,KTEMP9
    INTEGER,OPTIONAL :: KTEMP10,KTEMP11,KTEMP12,KTEMP13,KTEMP14,KTEMP15,KTEMP16,KTEMP17,KTEMP18
    INTEGER,OPTIONAL :: KTEMP19,KTEMP20

    IF (PRESENT(KTEMP20)) CALL MNH_REL_GT3D_N0(KTEMP20)
    IF (PRESENT(KTEMP19)) CALL MNH_REL_GT3D_N0(KTEMP19)
    IF (PRESENT(KTEMP18)) CALL MNH_REL_GT3D_N0(KTEMP18)
    IF (PRESENT(KTEMP17)) CALL MNH_REL_GT3D_N0(KTEMP17)
    IF (PRESENT(KTEMP16)) CALL MNH_REL_GT3D_N0(KTEMP16)
    IF (PRESENT(KTEMP15)) CALL MNH_REL_GT3D_N0(KTEMP15)
    IF (PRESENT(KTEMP14)) CALL MNH_REL_GT3D_N0(KTEMP14)
    IF (PRESENT(KTEMP13)) CALL MNH_REL_GT3D_N0(KTEMP13)
    IF (PRESENT(KTEMP12)) CALL MNH_REL_GT3D_N0(KTEMP12)
    IF (PRESENT(KTEMP11)) CALL MNH_REL_GT3D_N0(KTEMP11)
    IF (PRESENT(KTEMP10)) CALL MNH_REL_GT3D_N0(KTEMP10)
    IF (PRESENT(KTEMP9))  CALL MNH_REL_GT3D_N0(KTEMP9)
    IF (PRESENT(KTEMP8))  CALL MNH_REL_GT3D_N0(KTEMP8)
    IF (PRESENT(KTEMP7))  CALL MNH_REL_GT3D_N0(KTEMP7)
    IF (PRESENT(KTEMP6))  CALL MNH_REL_GT3D_N0(KTEMP6)
    IF (PRESENT(KTEMP5))  CALL MNH_REL_GT3D_N0(KTEMP5)
    IF (PRESENT(KTEMP4))  CALL MNH_REL_GT3D_N0(KTEMP4)
    IF (PRESENT(KTEMP3))  CALL MNH_REL_GT3D_N0(KTEMP3)
    IF (PRESENT(KTEMP2))  CALL MNH_REL_GT3D_N0(KTEMP2)
    CALL MNH_REL_GT3D_N0(KTEMP1)
    
  END SUBROUTINE MNH_REL_GT3D

    FUNCTION MNH_ALLOCATE_GT3D(PTAB,KI,KJ,KK) RESULT (KINDEX)
    
    LOGICAL, POINTER, CONTIGUOUS , DIMENSION(:,:,:), INTENT(INOUT) :: PTAB
    INTEGER , INTENT(IN)    :: KI,KJ,KK
    INTEGER                 :: KINDEX

    !local

    IF ( (KI .EQ. IIU) .AND. (KJ .EQ. IJU) .AND. (KK .EQ. IKU) ) THEN 
       CALL MNH_GET_GT3D_N0(KINDEX)
       PTAB => GT3D(:,:,:,KINDEX)
    ELSE
       call Print_msg( NVERB_ERROR, 'GEN', 'MNH_ALLOCATE_GT3D', ' Size mismatch ' )
    END IF
       
  END FUNCTION MNH_ALLOCATE_GT3D

  FUNCTION MNH_ALLOCATE_GT2D(PTAB,KI,KJ) RESULT (KINDEX)
    
    LOGICAL, POINTER, CONTIGUOUS , DIMENSION(:,:), INTENT(INOUT) :: PTAB
    INTEGER , INTENT(IN)    :: KI,KJ
    INTEGER                 :: KINDEX

    !local

    IF (KI .EQ. IIU) THEN
       CALL MNH_GET_GT3D_N0(KINDEX)
       IF (KJ .EQ. IJU) THEN 
          PTAB => GT3D(:,:,1,KINDEX)
       ELSE IF (KJ .EQ. 0)  THEN
          PTAB => GT2D_OSIZE
       ELSE
          call Print_msg( NVERB_ERROR, 'GEN', 'MNH_ALLOCATE_GT2D', ' Size mismatch ' )
       END IF
    ELSE
       call Print_msg( NVERB_ERROR, 'GEN', 'MNH_ALLOCATE_GT2D', ' Size mismatch ' )
    END IF
       
  END FUNCTION MNH_ALLOCATE_GT2D

  !------------ End Logical Pool

    !-------- Real 1D Pool Managment
  
    SUBROUTINE MNH_GET_ZT1D_N0(KTEMP)

    IMPLICIT NONE

    INTEGER :: KTEMP

    IF (NT1D_TOP_R == JPMAX_T1D_R ) THEN
      WRITE( *, '( " MNH_GET_ZT1D_N0: NT1D_TOP_R too big (increaze JPMAX_T1D_R) , NT1D_TOP_R=",I4 )' ) NT1D_TOP_R
      call Print_msg( NVERB_FATAL, 'GEN', 'MNH_GET_ZT1D_N0', 'NT1D_TOP_R too big (increaze JPMAX_T1D_R)' )
    ELSE
       NT1D_TOP_R = NT1D_TOP_R + 1
       KTEMP = NT1D_POOL_R(NT1D_TOP_R)
       NT1D_POOL_R(NT1D_TOP_R) = - KTEMP
       IF (  NT1D_TOP_R > NT1D_TOP_R_MAX ) THEN
          NT1D_TOP_R_MAX = NT1D_TOP_R
          !WRITE( *, '( " MNH_GET_ZT1D: NT1D_TOP_R_MAX=",I4," KTEMP=",I4 )' ) NT1D_TOP_R_MAX,KTEMP
       END IF
    ENDIF
    !WRITE( *, '( "MNH_GET_ZT1D: reserving ZT1D (",I4,")" )' ) KTEMP

  END SUBROUTINE MNH_GET_ZT1D_N0

  SUBROUTINE MNH_GET_ZT1D(KTEMP1,KTEMP2,KTEMP3,KTEMP4,KTEMP5,KTEMP6,KTEMP7,KTEMP8,KTEMP9, &
                          KTEMP10,KTEMP11,KTEMP12,KTEMP13,KTEMP14,KTEMP15,KTEMP16,KTEMP17,KTEMP18)

    IMPLICIT NONE

    INTEGER          :: KTEMP1
    INTEGER,OPTIONAL :: KTEMP2,KTEMP3,KTEMP4,KTEMP5,KTEMP6,KTEMP7,KTEMP8,KTEMP9
    INTEGER,OPTIONAL :: KTEMP10,KTEMP11,KTEMP12,KTEMP13,KTEMP14,KTEMP15,KTEMP16,KTEMP17,KTEMP18

                          CALL MNH_GET_ZT1D_N0(KTEMP1)
    IF (PRESENT(KTEMP2))  CALL MNH_GET_ZT1D_N0(KTEMP2)
    IF (PRESENT(KTEMP3))  CALL MNH_GET_ZT1D_N0(KTEMP3)
    IF (PRESENT(KTEMP4))  CALL MNH_GET_ZT1D_N0(KTEMP4)
    IF (PRESENT(KTEMP5))  CALL MNH_GET_ZT1D_N0(KTEMP5)
    IF (PRESENT(KTEMP6))  CALL MNH_GET_ZT1D_N0(KTEMP6)
    IF (PRESENT(KTEMP7))  CALL MNH_GET_ZT1D_N0(KTEMP7)
    IF (PRESENT(KTEMP8))  CALL MNH_GET_ZT1D_N0(KTEMP8)
    IF (PRESENT(KTEMP9))  CALL MNH_GET_ZT1D_N0(KTEMP9)
    IF (PRESENT(KTEMP10)) CALL MNH_GET_ZT1D_N0(KTEMP10)
    IF (PRESENT(KTEMP11)) CALL MNH_GET_ZT1D_N0(KTEMP11)
    IF (PRESENT(KTEMP12)) CALL MNH_GET_ZT1D_N0(KTEMP12)
    IF (PRESENT(KTEMP13)) CALL MNH_GET_ZT1D_N0(KTEMP13)
    IF (PRESENT(KTEMP14)) CALL MNH_GET_ZT1D_N0(KTEMP14)
    IF (PRESENT(KTEMP15)) CALL MNH_GET_ZT1D_N0(KTEMP15)
    IF (PRESENT(KTEMP16)) CALL MNH_GET_ZT1D_N0(KTEMP16)
    IF (PRESENT(KTEMP17)) CALL MNH_GET_ZT1D_N0(KTEMP17)
    IF (PRESENT(KTEMP18)) CALL MNH_GET_ZT1D_N0(KTEMP18)

  END SUBROUTINE MNH_GET_ZT1D

    SUBROUTINE MNH_REL_ZT1D_N0(KTEMP)

    IMPLICIT NONE

    INTEGER :: KTEMP

    IF ( ( NT1D_TOP_R > JPMAX_T1D_R ) .OR. ( NT1D_TOP_R < 1 ) ) THEN
      call Print_msg( NVERB_FATAL, 'GEN', 'MNH_REL_ZT1D_N0', 'invalid value for NT1D_TOP_R' )
    ELSE
      NT1D_POOL_R(KTEMP) = KTEMP
      IF (KTEMP == NT1D_TOP_R) THEN
        NT1D_TOP_R = NT1D_TOP_R - 1
     ELSE
        WRITE( *, '( "MNH_REL_ZT1D_N0: invalid value for KTEMP <> NT1D_TOP_R  (",2I8,")" )' ) KTEMP, NT1D_TOP_R
        FLUSH(6)
        call Print_msg( NVERB_FATAL, 'GEN', 'MNH_REL_ZT1D_N0', 'invalid value for KTEMP <> NT1D_TOP_R' )
      END IF
    ENDIF
    !WRITE( *, '( "MNH_REL_ZT1D_N0: releasing ZT1D (",I4,")" )' ) KTEMP

  END SUBROUTINE MNH_REL_ZT1D_N0

  SUBROUTINE MNH_REL_ZT1D(KTEMP1,KTEMP2,KTEMP3,KTEMP4,KTEMP5,KTEMP6,KTEMP7,KTEMP8,KTEMP9, &
                          KTEMP10,KTEMP11,KTEMP12,KTEMP13,KTEMP14,KTEMP15,KTEMP16,KTEMP17,KTEMP18, &
                          KTEMP19,KTEMP20)

    IMPLICIT NONE

    INTEGER          :: KTEMP1
    INTEGER,OPTIONAL :: KTEMP2,KTEMP3,KTEMP4,KTEMP5,KTEMP6,KTEMP7,KTEMP8,KTEMP9
    INTEGER,OPTIONAL :: KTEMP10,KTEMP11,KTEMP12,KTEMP13,KTEMP14,KTEMP15,KTEMP16,KTEMP17,KTEMP18
    INTEGER,OPTIONAL :: KTEMP19,KTEMP20

    IF (PRESENT(KTEMP20)) CALL MNH_REL_ZT1D_N0(KTEMP20)
    IF (PRESENT(KTEMP19)) CALL MNH_REL_ZT1D_N0(KTEMP19)
    IF (PRESENT(KTEMP18)) CALL MNH_REL_ZT1D_N0(KTEMP18)
    IF (PRESENT(KTEMP17)) CALL MNH_REL_ZT1D_N0(KTEMP17)
    IF (PRESENT(KTEMP16)) CALL MNH_REL_ZT1D_N0(KTEMP16)
    IF (PRESENT(KTEMP15)) CALL MNH_REL_ZT1D_N0(KTEMP15)
    IF (PRESENT(KTEMP14)) CALL MNH_REL_ZT1D_N0(KTEMP14)
    IF (PRESENT(KTEMP13)) CALL MNH_REL_ZT1D_N0(KTEMP13)
    IF (PRESENT(KTEMP12)) CALL MNH_REL_ZT1D_N0(KTEMP12)
    IF (PRESENT(KTEMP11)) CALL MNH_REL_ZT1D_N0(KTEMP11)
    IF (PRESENT(KTEMP10)) CALL MNH_REL_ZT1D_N0(KTEMP10)
    IF (PRESENT(KTEMP9))  CALL MNH_REL_ZT1D_N0(KTEMP9)
    IF (PRESENT(KTEMP8))  CALL MNH_REL_ZT1D_N0(KTEMP8)
    IF (PRESENT(KTEMP7))  CALL MNH_REL_ZT1D_N0(KTEMP7)
    IF (PRESENT(KTEMP6))  CALL MNH_REL_ZT1D_N0(KTEMP6)
    IF (PRESENT(KTEMP5))  CALL MNH_REL_ZT1D_N0(KTEMP5)
    IF (PRESENT(KTEMP4))  CALL MNH_REL_ZT1D_N0(KTEMP4)
    IF (PRESENT(KTEMP3))  CALL MNH_REL_ZT1D_N0(KTEMP3)
    IF (PRESENT(KTEMP2))  CALL MNH_REL_ZT1D_N0(KTEMP2)
    CALL MNH_REL_ZT1D_N0(KTEMP1)
    
  END SUBROUTINE MNH_REL_ZT1D

  FUNCTION MNH_ALLOCATE_ZT1D(PTAB,KI) RESULT (KINDEX)
    
    REAL, POINTER, CONTIGUOUS , DIMENSION(:), INTENT(INOUT) :: PTAB
    INTEGER , INTENT(IN)    :: KI
    INTEGER                 :: KINDEX

    !local

    IF (KI .EQ. IIJKU) THEN 
       CALL MNH_GET_ZT1D_N0(KINDEX)
       PTAB => ZT1D(:,KINDEX)
    ELSE
       call Print_msg( NVERB_ERROR, 'GEN', 'MNH_ALLOCATE_ZT1D', ' Size mismatch ' )
    END IF
    !WRITE( *, '( "MNH_ALLOCATE_ZT1D: KI=(",I4,") , KINDEX=(",I4,")" )' ) KI,KINDEX
    !FLUSH(6) 
       
  END FUNCTION MNH_ALLOCATE_ZT1D

  FUNCTION MNH_ALLOCATE_ZT1DP(PTAB,KI) RESULT (KINDEX)
    
    REAL, POINTER, CONTIGUOUS , DIMENSION(:), INTENT(INOUT) :: PTAB
    INTEGER , INTENT(IN)    :: KI
    INTEGER                 :: KINDEX

    !local

    IF (KI .LE. IIJKU) THEN 
       CALL MNH_GET_ZT1D_N0(KINDEX)
       IF (KI .NE. 0) THEN
          PTAB(1:KI) => ZT1D(:,KINDEX)
       ELSE
          PTAB => ZT1D_OSIZE
       END IF
    ELSE
       call Print_msg( NVERB_ERROR, 'GEN', 'MNH_ALLOCATE_ZT1DP', ' Size mismatch ' )
    END IF
    !WRITE( *, '( "MNH_ALLOCATE_ZT1DP: KI=(",I9,") , KINDEX=(",I4,")" )' ) KI,KINDEX
    
  END FUNCTION MNH_ALLOCATE_ZT1DP

  ! End Real 1D management
  
  !-------- Integer 1D Pool Managment
  
    SUBROUTINE MNH_GET_IT1D_N0(KTEMP)

    IMPLICIT NONE

    INTEGER :: KTEMP

    IF (NT1D_TOP_I == JPMAX_T1D_I ) THEN
      WRITE( *, '( " MNH_GET_IT1D_N0: NT1D_TOP_I too big (increaze JPMAX_T1D_I) , NT1D_TOP_I=",I4 )' ) NT1D_TOP_I
      call Print_msg( NVERB_FATAL, 'GEN', 'MNH_GET_IT1D_N0', 'NT1D_TOP_I too big (increaze JPMAX_T1D_I)' )
    ELSE
       NT1D_TOP_I = NT1D_TOP_I + 1
       KTEMP = NT1D_POOL_I(NT1D_TOP_I)
       NT1D_POOL_I(NT1D_TOP_I) = - KTEMP
       IF (  NT1D_TOP_I > NT1D_TOP_I_MAX ) THEN
          NT1D_TOP_I_MAX = NT1D_TOP_I
          !WRITE( *, '( " MNH_GET_IT1D: NT1D_TOP_I_MAX=",I4," KTEMP=",I4 )' ) NT1D_TOP_I_MAX,KTEMP
       END IF
    ENDIF
    !WRITE( *, '( "MNH_GET_IT1D: reserving IT1D (",I4,")" )' ) KTEMP

  END SUBROUTINE MNH_GET_IT1D_N0

  SUBROUTINE MNH_GET_IT1D(KTEMP1,KTEMP2,KTEMP3,KTEMP4,KTEMP5,KTEMP6,KTEMP7,KTEMP8,KTEMP9, &
                          KTEMP10,KTEMP11,KTEMP12,KTEMP13,KTEMP14,KTEMP15,KTEMP16,KTEMP17,KTEMP18)

    IMPLICIT NONE

    INTEGER          :: KTEMP1
    INTEGER,OPTIONAL :: KTEMP2,KTEMP3,KTEMP4,KTEMP5,KTEMP6,KTEMP7,KTEMP8,KTEMP9
    INTEGER,OPTIONAL :: KTEMP10,KTEMP11,KTEMP12,KTEMP13,KTEMP14,KTEMP15,KTEMP16,KTEMP17,KTEMP18

                          CALL MNH_GET_IT1D_N0(KTEMP1)
    IF (PRESENT(KTEMP2))  CALL MNH_GET_IT1D_N0(KTEMP2)
    IF (PRESENT(KTEMP3))  CALL MNH_GET_IT1D_N0(KTEMP3)
    IF (PRESENT(KTEMP4))  CALL MNH_GET_IT1D_N0(KTEMP4)
    IF (PRESENT(KTEMP5))  CALL MNH_GET_IT1D_N0(KTEMP5)
    IF (PRESENT(KTEMP6))  CALL MNH_GET_IT1D_N0(KTEMP6)
    IF (PRESENT(KTEMP7))  CALL MNH_GET_IT1D_N0(KTEMP7)
    IF (PRESENT(KTEMP8))  CALL MNH_GET_IT1D_N0(KTEMP8)
    IF (PRESENT(KTEMP9))  CALL MNH_GET_IT1D_N0(KTEMP9)
    IF (PRESENT(KTEMP10)) CALL MNH_GET_IT1D_N0(KTEMP10)
    IF (PRESENT(KTEMP11)) CALL MNH_GET_IT1D_N0(KTEMP11)
    IF (PRESENT(KTEMP12)) CALL MNH_GET_IT1D_N0(KTEMP12)
    IF (PRESENT(KTEMP13)) CALL MNH_GET_IT1D_N0(KTEMP13)
    IF (PRESENT(KTEMP14)) CALL MNH_GET_IT1D_N0(KTEMP14)
    IF (PRESENT(KTEMP15)) CALL MNH_GET_IT1D_N0(KTEMP15)
    IF (PRESENT(KTEMP16)) CALL MNH_GET_IT1D_N0(KTEMP16)
    IF (PRESENT(KTEMP17)) CALL MNH_GET_IT1D_N0(KTEMP17)
    IF (PRESENT(KTEMP18)) CALL MNH_GET_IT1D_N0(KTEMP18)

  END SUBROUTINE MNH_GET_IT1D

    SUBROUTINE MNH_REL_IT1D_N0(KTEMP)

    IMPLICIT NONE

    INTEGER :: KTEMP

    IF ( ( NT1D_TOP_I > JPMAX_T1D_I ) .OR. ( NT1D_TOP_I < 1 ) ) THEN
      call Print_msg( NVERB_FATAL, 'GEN', 'MNH_REL_IT1D_N0', 'invalid value for NT1D_TOP_I' )
    ELSE
      NT1D_POOL_I(KTEMP) = KTEMP
      IF (KTEMP == NT1D_TOP_I) THEN
        NT1D_TOP_I = NT1D_TOP_I - 1
     ELSE
        WRITE( *, '( "MNH_REL_IT1D_N0: invalid value for KTEMP <> NT1D_TOP_I  (",2I8,")" )' ) KTEMP, NT1D_TOP_I
        FLUSH(6)
        call Print_msg( NVERB_FATAL, 'GEN', 'MNH_REL_IT1D_N0', 'invalid value for KTEMP <> NT1D_TOP_R' )
      END IF
    ENDIF
    !WRITE( *, '( "MNH_REL_IT1D_N0: releasing IT1D (",I4,")" )' ) KTEMP

  END SUBROUTINE MNH_REL_IT1D_N0

  SUBROUTINE MNH_REL_IT1D(KTEMP1,KTEMP2,KTEMP3,KTEMP4,KTEMP5,KTEMP6,KTEMP7,KTEMP8,KTEMP9, &
                          KTEMP10,KTEMP11,KTEMP12,KTEMP13,KTEMP14,KTEMP15,KTEMP16,KTEMP17,KTEMP18, &
                          KTEMP19,KTEMP20)

    IMPLICIT NONE

    INTEGER          :: KTEMP1
    INTEGER,OPTIONAL :: KTEMP2,KTEMP3,KTEMP4,KTEMP5,KTEMP6,KTEMP7,KTEMP8,KTEMP9
    INTEGER,OPTIONAL :: KTEMP10,KTEMP11,KTEMP12,KTEMP13,KTEMP14,KTEMP15,KTEMP16,KTEMP17,KTEMP18
    INTEGER,OPTIONAL :: KTEMP19,KTEMP20

    IF (PRESENT(KTEMP20)) CALL MNH_REL_IT1D_N0(KTEMP20)
    IF (PRESENT(KTEMP19)) CALL MNH_REL_IT1D_N0(KTEMP19)
    IF (PRESENT(KTEMP18)) CALL MNH_REL_IT1D_N0(KTEMP18)
    IF (PRESENT(KTEMP17)) CALL MNH_REL_IT1D_N0(KTEMP17)
    IF (PRESENT(KTEMP16)) CALL MNH_REL_IT1D_N0(KTEMP16)
    IF (PRESENT(KTEMP15)) CALL MNH_REL_IT1D_N0(KTEMP15)
    IF (PRESENT(KTEMP14)) CALL MNH_REL_IT1D_N0(KTEMP14)
    IF (PRESENT(KTEMP13)) CALL MNH_REL_IT1D_N0(KTEMP13)
    IF (PRESENT(KTEMP12)) CALL MNH_REL_IT1D_N0(KTEMP12)
    IF (PRESENT(KTEMP11)) CALL MNH_REL_IT1D_N0(KTEMP11)
    IF (PRESENT(KTEMP10)) CALL MNH_REL_IT1D_N0(KTEMP10)
    IF (PRESENT(KTEMP9))  CALL MNH_REL_IT1D_N0(KTEMP9)
    IF (PRESENT(KTEMP8))  CALL MNH_REL_IT1D_N0(KTEMP8)
    IF (PRESENT(KTEMP7))  CALL MNH_REL_IT1D_N0(KTEMP7)
    IF (PRESENT(KTEMP6))  CALL MNH_REL_IT1D_N0(KTEMP6)
    IF (PRESENT(KTEMP5))  CALL MNH_REL_IT1D_N0(KTEMP5)
    IF (PRESENT(KTEMP4))  CALL MNH_REL_IT1D_N0(KTEMP4)
    IF (PRESENT(KTEMP3))  CALL MNH_REL_IT1D_N0(KTEMP3)
    IF (PRESENT(KTEMP2))  CALL MNH_REL_IT1D_N0(KTEMP2)
    CALL MNH_REL_IT1D_N0(KTEMP1)
    
  END SUBROUTINE MNH_REL_IT1D

  FUNCTION MNH_ALLOCATE_IT1D(PTAB,KI) RESULT (KINDEX)
    
    INTEGER, POINTER, CONTIGUOUS , DIMENSION(:), INTENT(INOUT) :: PTAB
    INTEGER , INTENT(IN)    :: KI
    INTEGER                 :: KINDEX

    !local

    IF (KI .EQ. IIJKU) THEN 
       CALL MNH_GET_IT1D_N0(KINDEX)
       PTAB => IT1D(:,KINDEX)
    ELSE
       call Print_msg( NVERB_ERROR, 'GEN', 'MNH_ALLOCATE_IT1D', ' Size mismatch ' )
    END IF
    !WRITE( *, '( "MNH_ALLOCATE_IT1D: KI=(",I4,") , KINDEX=(",I4,")" )' ) KI,KINDEX
    !FLUSH(6) 
       
  END FUNCTION MNH_ALLOCATE_IT1D

  FUNCTION MNH_ALLOCATE_IT1DP(PTAB,KI) RESULT (KINDEX)
    
    INTEGER, POINTER, CONTIGUOUS , DIMENSION(:), INTENT(INOUT) :: PTAB
    INTEGER , INTENT(IN)    :: KI
    INTEGER                 :: KINDEX

    !local

    IF (KI .LE. IIJKU) THEN 
       CALL MNH_GET_IT1D_N0(KINDEX)
       IF (KI .NE. 0) THEN
          PTAB(1:KI) => IT1D(1:KI,KINDEX)
       ELSE
          PTAB => IT1D_OSIZE
       END IF
    ELSE
       call Print_msg( NVERB_ERROR, 'GEN', 'MNH_ALLOCATE_IT1DP', ' Size mismatch ' )
    END IF
    !WRITE( *, '( "MNH_ALLOCATE_IT1DP: KI=(",I9,") , KINDEX=(",I4,")" )' ) KI,KINDEX
    
  END FUNCTION MNH_ALLOCATE_IT1DP

  ! End Integer 1D management

  !-------- Logical 1DFLAT Pool Managment

  FUNCTION MNH_GET_GT1DFLAT( KSIZE ) RESULT( KINDEX )

    USE MODD_PARAMETERS, ONLY: NNEGUNDEF

    IMPLICIT NONE

    INTEGER(KIND=MNHINT64), INTENT(IN)  :: KSIZE
    INTEGER                             :: KINDEX

    CHARACTER(LEN=32) :: YAVAIL, YMAX, YSIZE
    INTEGER(KIND=MNHINT64), ALLOCATABLE, DIMENSION (:) :: IT1DFLAT_POOL_G
    INTEGER(KIND=MNHINT64), ALLOCATABLE, DIMENSION (:) :: IT1DFLAT_SIZE_G

    NCALL_MNH_GET_GT1DFLAT = NCALL_MNH_GET_GT1DFLAT + 1
    NTOT_GETSIZE_GT1DFLAT  = NTOT_GETSIZE_GT1DFLAT + KSIZE

    IF ( NT1DFLAT_POS_G + KSIZE > NT1DFLAT_MAXSIZE_G ) THEN
      WRITE( YSIZE,  '( I0 )' ) KSIZE
      WRITE( YAVAIL, '( I0 )' ) NT1DFLAT_MAXSIZE_G - NT1DFLAT_POS_G
      WRITE( YMAX,   '( I0 )' ) NT1DFLAT_MAXSIZE_G
      call Print_msg( NVERB_FATAL, 'GEN', 'MNH_GET_GT1DFLAT', 'GT1DFLAT too small (asked=' // Trim( ysize ) // &
                      ', available=' // Trim( yavail ) // ', total=' // Trim( ymax ) // ')' )
    ELSE
      NT1DFLAT_TOP_G = NT1DFLAT_TOP_G + 1
      KINDEX = NT1DFLAT_TOP_G

      IF ( KINDEX > NPMAX_POOL_T1DFLAT_G ) THEN
        WRITE( YSIZE,  '( I0 )' ) NPMAX_POOL_T1DFLAT_G
        WRITE( YMAX,   '( I0 )' ) NPMAX_POOL_T1DFLAT_G+JPPOOLSTEP_FLAT
        call Print_msg( NVERB_INFO, 'GEN', 'MNH_GET_GT1DFLAT', 'pool for GT1DFLAT was too small (' // TRIM( YSIZE ) &
                        // '->' // TRIM( YMAX ) // ')' )

        ALLOCATE( IT1DFLAT_POOL_G(NPMAX_POOL_T1DFLAT_G+JPPOOLSTEP_FLAT) )
        ALLOCATE( IT1DFLAT_SIZE_G(NPMAX_POOL_T1DFLAT_G+JPPOOLSTEP_FLAT) )

        IT1DFLAT_POOL_G(1:NPMAX_POOL_T1DFLAT_G) = NT1DFLAT_POOL_G(:)
        IT1DFLAT_SIZE_G(1:NPMAX_POOL_T1DFLAT_G) = NT1DFLAT_SIZE_G(:)
        IT1DFLAT_POOL_G(NPMAX_POOL_T1DFLAT_G+1:) = NNEGUNDEF
        IT1DFLAT_SIZE_G(NPMAX_POOL_T1DFLAT_G+1:) = NNEGUNDEF

        CALL MOVE_ALLOC( FROM = IT1DFLAT_POOL_G, TO = NT1DFLAT_POOL_G )
        CALL MOVE_ALLOC( FROM = IT1DFLAT_SIZE_G, TO = NT1DFLAT_SIZE_G )

        NPMAX_POOL_T1DFLAT_G = NPMAX_POOL_T1DFLAT_G + JPPOOLSTEP_FLAT
      END IF

#if ( MNH_MEM_ALIGN == 1 )
      ! Align position on alignment boundaries
      IF ( MOD( NT1DFLAT_POS_G, NALIGNSIZE_BOOL ) == 0 ) THEN
        NT1DFLAT_POOL_G( KINDEX ) = NT1DFLAT_POS_G + 1
      ELSE
        ! Pad values to boundary
        NT1DFLAT_POOL_G( KINDEX ) = NT1DFLAT_POS_G + ( NALIGNSIZE_BOOL - MOD( NT1DFLAT_POS_G-1, NALIGNSIZE_BOOL ) )
      END IF
#else
      NT1DFLAT_POOL_G( KINDEX ) = NT1DFLAT_POS_G + 1
#endif
      NT1DFLAT_SIZE_G( KINDEX ) = KSIZE

      NT1DFLAT_POS_G = NT1DFLAT_POOL_G( KINDEX ) + KSIZE - 1

      IF ( NT1DFLAT_TOP_G > NT1DFLAT_TOP_G_MAX ) NT1DFLAT_TOP_G_MAX = NT1DFLAT_TOP_G
      IF ( NT1DFLAT_POS_G > NT1DFLAT_POS_G_MAX ) NT1DFLAT_POS_G_MAX = NT1DFLAT_POS_G
    END IF

  END FUNCTION MNH_GET_GT1DFLAT


  SUBROUTINE MNH_REL_GT1DFLAT( KINDEX )

    USE MODD_PARAMETERS, ONLY: NNEGUNDEF

    IMPLICIT NONE

    INTEGER :: KINDEX

    NCALL_MNH_REL_GT1DFLAT = NCALL_MNH_REL_GT1DFLAT + 1

    !Release only if last block
    IF ( KINDEX /= NT1DFLAT_TOP_G ) &
      call Print_msg( NVERB_FATAL, 'GEN', 'MNH_REL_GT1DFLAT', 'trying to release block that is not the last one' )

    NTOT_RELSIZE_GT1DFLAT = NTOT_RELSIZE_GT1DFLAT + NT1DFLAT_SIZE_G( KINDEX )

    NT1DFLAT_TOP_G = NT1DFLAT_TOP_G - 1
    NT1DFLAT_POS_G = NT1DFLAT_POS_G - NT1DFLAT_SIZE_G( KINDEX )

    NT1DFLAT_POOL_G( KINDEX ) = NNEGUNDEF
    NT1DFLAT_SIZE_G( KINDEX ) = NNEGUNDEF

  END SUBROUTINE MNH_REL_GT1DFLAT

  SUBROUTINE MNH_ALLOCATE_GT1DFLAT_SIZE_INT32( PTAB, KIB, KIE )

    LOGICAL, POINTER, CONTIGUOUS , DIMENSION(:), INTENT(INOUT) :: PTAB
    INTEGER(KIND=MNHINT32),                   INTENT(IN)    :: KIB
    INTEGER(KIND=MNHINT32),                   INTENT(IN)    :: KIE
    INTEGER :: ISIZE
    ISIZE = (KIE - KIB + 1)
    CALL MNH_ALLOCATE_GT1DFLAT_INT32( PTAB, INT( ISIZE, KIND = MNHINT32 ) )

  END SUBROUTINE MNH_ALLOCATE_GT1DFLAT_SIZE_INT32

  SUBROUTINE MNH_ALLOCATE_GT1DFLAT_SIZE_INT64( PTAB, KIB, KIE )

    LOGICAL, POINTER, CONTIGUOUS , DIMENSION(:), INTENT(INOUT) :: PTAB
    INTEGER(KIND=MNHINT64),                   INTENT(IN)    :: KIB
    INTEGER(KIND=MNHINT64),                   INTENT(IN)    :: KIE
    INTEGER :: ISIZE
    ISIZE = (KIE - KIB + 1)
    CALL MNH_ALLOCATE_GT1DFLAT_INT64( PTAB, INT( ISIZE, KIND = MNHINT64 ) )

  END SUBROUTINE MNH_ALLOCATE_GT1DFLAT_SIZE_INT64


  SUBROUTINE MNH_ALLOCATE_GT1DFLAT_INT32( OTAB, KSIZE )

    LOGICAL, POINTER, CONTIGUOUS , DIMENSION(:), INTENT(INOUT) :: OTAB
    INTEGER(KIND=MNHINT32),                      INTENT(IN)    :: KSIZE

    call MNH_Allocate_gt1dflat_int64( otab, Int( ksize, kind = MNHINT64 ) )

  END SUBROUTINE MNH_ALLOCATE_GT1DFLAT_INT32


  SUBROUTINE MNH_ALLOCATE_GT1DFLAT_INT64( OTAB, KSIZE )

    LOGICAL, POINTER, CONTIGUOUS , DIMENSION(:), INTENT(INOUT) :: OTAB
    INTEGER(KIND=MNHINT64),                      INTENT(IN)    :: KSIZE

    INTEGER :: IPOS

    NCALL_MNH_ALLOCATE_GT1DFLAT = NCALL_MNH_ALLOCATE_GT1DFLAT + 1
    NTOT_ALLOCSIZE_GT1DFLAT     = NTOT_ALLOCSIZE_GT1DFLAT + KSIZE

    ipos = MNH_Get_gt1dflat( ksize )
    otab(1:KSIZE) => gt1dflat( NT1DFLAT_POOL_G(ipos) : NT1DFLAT_POOL_G(ipos)+ksize-1 )

  END SUBROUTINE MNH_ALLOCATE_GT1DFLAT_INT64


  SUBROUTINE MNH_ALLOCATE_GT2DFLAT( OTAB, KIB, KIE, KJB, KJE )

    LOGICAL, POINTER, CONTIGUOUS , DIMENSION(:,:), INTENT(INOUT) :: OTAB
    INTEGER,                                       INTENT(IN)    :: KIB
    INTEGER,                                       INTENT(IN)    :: KIE
    INTEGER,                                       INTENT(IN)    :: KJB
    INTEGER,                                       INTENT(IN)    :: KJE

    INTEGER                :: IPOS
    INTEGER(KIND=MNHINT64) :: ISIZE
    INTEGER(KIND=MNHINT64) :: IIB, IIE, IJB, IJE

    NCALL_MNH_ALLOCATE_GT2DFLAT = NCALL_MNH_ALLOCATE_GT2DFLAT + 1

    IIB = KIB
    IIE = KIE
    IJB = KJB
    IJE = KJE

    ISIZE = ( IIE - IIB + 1_MNHINT64 ) * ( IJE - IJB + 1_MNHINT64 )

    NTOT_ALLOCSIZE_GT2DFLAT = NTOT_ALLOCSIZE_GT2DFLAT + ISIZE

    ipos = MNH_Get_gt1dflat( isize )

    otab(KIB:KIE, KJB:KJE) => gt1dflat( NT1DFLAT_POOL_G(ipos) : NT1DFLAT_POOL_G(ipos)+isize-1 )

  END SUBROUTINE MNH_ALLOCATE_GT2DFLAT


  SUBROUTINE MNH_ALLOCATE_GT2DFLAT_SIZE( OTAB, KISIZE, KJSIZE )

    LOGICAL, POINTER, CONTIGUOUS , DIMENSION(:,:), INTENT(INOUT) :: OTAB
    INTEGER,                                       INTENT(IN)    :: KISIZE
    INTEGER,                                       INTENT(IN)    :: KJSIZE

    CALL MNH_ALLOCATE_GT2DFLAT( OTAB, 1, KISIZE, 1, KJSIZE )

  END SUBROUTINE MNH_ALLOCATE_GT2DFLAT_SIZE


  SUBROUTINE MNH_ALLOCATE_GT3DFLAT( OTAB, KIB, KIE, KJB, KJE, KKB, KKE )

    LOGICAL, POINTER, CONTIGUOUS , DIMENSION(:,:,:), INTENT(INOUT) :: OTAB
    INTEGER,                                         INTENT(IN)    :: KIB
    INTEGER,                                         INTENT(IN)    :: KIE
    INTEGER,                                         INTENT(IN)    :: KJB
    INTEGER,                                         INTENT(IN)    :: KJE
    INTEGER,                                         INTENT(IN)    :: KKB
    INTEGER,                                         INTENT(IN)    :: KKE

    INTEGER                :: IPOS
    INTEGER(KIND=MNHINT64) :: ISIZE
    INTEGER(KIND=MNHINT64) :: IIB, IIE, IJB, IJE, IKB, IKE

    NCALL_MNH_ALLOCATE_GT3DFLAT = NCALL_MNH_ALLOCATE_GT3DFLAT + 1

    IIB = KIB
    IIE = KIE
    IJB = KJB
    IJE = KJE
    IKB = KKB
    IKE = KKE

    ISIZE = ( IIE - IIB + 1_MNHINT64 ) * ( IJE - IJB + 1_MNHINT64 ) * ( IKE - IKB + 1_MNHINT64 )

    NTOT_ALLOCSIZE_GT3DFLAT = NTOT_ALLOCSIZE_GT3DFLAT + ISIZE

    ipos = MNH_Get_gt1dflat( isize )

    otab(KIB:KIE, KJB:KJE, KKB:KKE) => gt1dflat( NT1DFLAT_POOL_G(ipos) : NT1DFLAT_POOL_G(ipos)+isize-1 )

  END SUBROUTINE MNH_ALLOCATE_GT3DFLAT


  SUBROUTINE MNH_ALLOCATE_GT3DFLAT_SIZE( OTAB, KISIZE, KJSIZE, KKSIZE )

    LOGICAL, POINTER, CONTIGUOUS , DIMENSION(:,:,:), INTENT(INOUT) :: OTAB
    INTEGER,                                         INTENT(IN)    :: KISIZE
    INTEGER,                                         INTENT(IN)    :: KJSIZE
    INTEGER,                                         INTENT(IN)    :: KKSIZE

    CALL MNH_ALLOCATE_GT3DFLAT( OTAB, 1, KISIZE, 1, KJSIZE, 1, KKSIZE )

  END SUBROUTINE MNH_ALLOCATE_GT3DFLAT_SIZE


  ! End Logical 1DFLAT management


  !-------- Integer 1DFLAT Pool Managment

  FUNCTION MNH_GET_IT1DFLAT( KSIZE ) RESULT( KINDEX )

    USE MODD_PARAMETERS, ONLY: NNEGUNDEF

    IMPLICIT NONE

    INTEGER(KIND=MNHINT64), INTENT(IN)  :: KSIZE
    INTEGER                             :: KINDEX

    CHARACTER(LEN=32) :: YAVAIL, YMAX, YSIZE
    INTEGER(KIND=MNHINT64), ALLOCATABLE, DIMENSION (:) :: IT1DFLAT_POOL_I
    INTEGER(KIND=MNHINT64), ALLOCATABLE, DIMENSION (:) :: IT1DFLAT_SIZE_I

    NCALL_MNH_GET_IT1DFLAT = NCALL_MNH_GET_IT1DFLAT + 1
    NTOT_GETSIZE_IT1DFLAT  = NTOT_GETSIZE_IT1DFLAT + KSIZE

    IF ( NT1DFLAT_POS_I + KSIZE > NT1DFLAT_MAXSIZE_I ) THEN
      WRITE( YSIZE,  '( I0 )' ) KSIZE
      WRITE( YAVAIL, '( I0 )' ) NT1DFLAT_MAXSIZE_I - NT1DFLAT_POS_I
      WRITE( YMAX,   '( I0 )' ) NT1DFLAT_MAXSIZE_I
      call Print_msg( NVERB_FATAL, 'GEN', 'MNH_GET_IT1DFLAT', 'IT1DFLAT too small (asked=' // Trim( ysize ) // &
                      ', available=' // Trim( yavail ) // ', total=' // Trim( ymax ) // ')' )
    ELSE
      NT1DFLAT_TOP_I = NT1DFLAT_TOP_I + 1
      KINDEX = NT1DFLAT_TOP_I

      IF ( KINDEX > NPMAX_POOL_T1DFLAT_I ) THEN
        WRITE( YSIZE,  '( I0 )' ) NPMAX_POOL_T1DFLAT_I
        WRITE( YMAX,   '( I0 )' ) NPMAX_POOL_T1DFLAT_I+JPPOOLSTEP_FLAT
        call Print_msg( NVERB_INFO, 'GEN', 'MNH_GET_IT1DFLAT', 'pool for IT1DFLAT was too small (' // TRIM( YSIZE ) &
                        // '->' // TRIM( YMAX ) // ')' )

        ALLOCATE( IT1DFLAT_POOL_I(NPMAX_POOL_T1DFLAT_I+JPPOOLSTEP_FLAT) )
        ALLOCATE( IT1DFLAT_SIZE_I(NPMAX_POOL_T1DFLAT_I+JPPOOLSTEP_FLAT) )

        IT1DFLAT_POOL_I(1:NPMAX_POOL_T1DFLAT_I) = NT1DFLAT_POOL_I(:)
        IT1DFLAT_SIZE_I(1:NPMAX_POOL_T1DFLAT_I) = NT1DFLAT_SIZE_I(:)
        IT1DFLAT_POOL_I(NPMAX_POOL_T1DFLAT_I+1:) = NNEGUNDEF
        IT1DFLAT_SIZE_I(NPMAX_POOL_T1DFLAT_I+1:) = NNEGUNDEF

        CALL MOVE_ALLOC( FROM = IT1DFLAT_POOL_I, TO = NT1DFLAT_POOL_I )
        CALL MOVE_ALLOC( FROM = IT1DFLAT_SIZE_I, TO = NT1DFLAT_SIZE_I )

        NPMAX_POOL_T1DFLAT_I = NPMAX_POOL_T1DFLAT_I + JPPOOLSTEP_FLAT
      END IF

#if ( MNH_MEM_ALIGN == 1 )
      ! Align position on alignment boundaries
      IF ( MOD( NT1DFLAT_POS_I, NALIGNSIZE_INT ) == 0 ) THEN
        NT1DFLAT_POOL_I( KINDEX ) = NT1DFLAT_POS_I + 1
      ELSE
        ! Pad values to boundary
        NT1DFLAT_POOL_I( KINDEX ) = NT1DFLAT_POS_I + ( NALIGNSIZE_INT - MOD( NT1DFLAT_POS_I-1, NALIGNSIZE_INT ) )
      END IF
#else
      NT1DFLAT_POOL_I( KINDEX ) = NT1DFLAT_POS_I + 1
#endif
      NT1DFLAT_SIZE_I( KINDEX ) = KSIZE

      NT1DFLAT_POS_I = NT1DFLAT_POOL_I( KINDEX ) + KSIZE - 1

      IF ( NT1DFLAT_TOP_I > NT1DFLAT_TOP_I_MAX ) NT1DFLAT_TOP_I_MAX = NT1DFLAT_TOP_I
      IF ( NT1DFLAT_POS_I > NT1DFLAT_POS_I_MAX ) NT1DFLAT_POS_I_MAX = NT1DFLAT_POS_I
    END IF

  END FUNCTION MNH_GET_IT1DFLAT


  SUBROUTINE MNH_REL_IT1DFLAT( KINDEX )

    USE MODD_PARAMETERS, ONLY: NNEGUNDEF

    IMPLICIT NONE

    INTEGER :: KINDEX

    NCALL_MNH_REL_IT1DFLAT = NCALL_MNH_REL_IT1DFLAT + 1

    !Release only if last block
    IF ( KINDEX /= NT1DFLAT_TOP_I ) &
      call Print_msg( NVERB_FATAL, 'GEN', 'MNH_REL_IT1DFLAT', 'trying to release block that is not the last one' )

    NTOT_RELSIZE_IT1DFLAT = NTOT_RELSIZE_IT1DFLAT + NT1DFLAT_SIZE_I( KINDEX )

    NT1DFLAT_TOP_I = NT1DFLAT_TOP_I - 1
    NT1DFLAT_POS_I = NT1DFLAT_POS_I - NT1DFLAT_SIZE_I( KINDEX )

    NT1DFLAT_POOL_I( KINDEX ) = NNEGUNDEF
    NT1DFLAT_SIZE_I( KINDEX ) = NNEGUNDEF

  END SUBROUTINE MNH_REL_IT1DFLAT

  SUBROUTINE MNH_ALLOCATE_IT1DFLAT_SIZE_INT32( PTAB, KIB, KIE )

    INTEGER, POINTER, CONTIGUOUS , DIMENSION(:), INTENT(INOUT) :: PTAB
    INTEGER(KIND=MNHINT32),                   INTENT(IN)    :: KIB
    INTEGER(KIND=MNHINT32),                   INTENT(IN)    :: KIE
    INTEGER :: ISIZE
    ISIZE = (KIE - KIB + 1)
    CALL MNH_ALLOCATE_IT1DFLAT_INT32( PTAB, INT( ISIZE, KIND = MNHINT32 ) )

  END SUBROUTINE MNH_ALLOCATE_IT1DFLAT_SIZE_INT32

  SUBROUTINE MNH_ALLOCATE_IT1DFLAT_SIZE_INT64( PTAB, KIB, KIE )

    INTEGER, POINTER, CONTIGUOUS , DIMENSION(:), INTENT(INOUT) :: PTAB
    INTEGER(KIND=MNHINT64),                   INTENT(IN)    :: KIB
    INTEGER(KIND=MNHINT64),                   INTENT(IN)    :: KIE
    INTEGER :: ISIZE
    ISIZE = (KIE - KIB + 1)
    CALL MNH_ALLOCATE_IT1DFLAT_INT64( PTAB, INT( ISIZE, KIND = MNHINT64 ) )

  END SUBROUTINE MNH_ALLOCATE_IT1DFLAT_SIZE_INT64

  SUBROUTINE MNH_ALLOCATE_IT1DFLAT_INT32( KTAB, KSIZE )

    INTEGER, POINTER, CONTIGUOUS , DIMENSION(:), INTENT(INOUT) :: KTAB
    INTEGER(KIND=MNHINT32),                      INTENT(IN)    :: KSIZE

    call MNH_Allocate_it1dflat_int64( ktab, Int( ksize, kind = MNHINT64 ) )

  END SUBROUTINE MNH_ALLOCATE_IT1DFLAT_INT32


  SUBROUTINE MNH_ALLOCATE_IT1DFLAT_INT64( KTAB, KSIZE )

    INTEGER, POINTER, CONTIGUOUS , DIMENSION(:), INTENT(INOUT) :: KTAB
    INTEGER(KIND=MNHINT64),                      INTENT(IN)    :: KSIZE

    INTEGER :: IPOS

    NCALL_MNH_ALLOCATE_IT1DFLAT = NCALL_MNH_ALLOCATE_IT1DFLAT + 1
    NTOT_ALLOCSIZE_IT1DFLAT     = NTOT_ALLOCSIZE_IT1DFLAT + KSIZE

    ipos = MNH_Get_it1dflat( ksize )
    ktab(1:KSIZE) => it1dflat( NT1DFLAT_POOL_I(ipos) : NT1DFLAT_POOL_I(ipos)+ksize-1 )

  END SUBROUTINE MNH_ALLOCATE_IT1DFLAT_INT64


  SUBROUTINE MNH_ALLOCATE_IT2DFLAT( KTAB, KIB, KIE, KJB, KJE )

    INTEGER, POINTER, CONTIGUOUS , DIMENSION(:,:), INTENT(INOUT) :: KTAB
    INTEGER,                                       INTENT(IN)    :: KIB
    INTEGER,                                       INTENT(IN)    :: KIE
    INTEGER,                                       INTENT(IN)    :: KJB
    INTEGER,                                       INTENT(IN)    :: KJE

    INTEGER                :: IPOS
    INTEGER(KIND=MNHINT64) :: ISIZE
    INTEGER(KIND=MNHINT64) :: IIB, IIE, IJB, IJE

    NCALL_MNH_ALLOCATE_IT2DFLAT = NCALL_MNH_ALLOCATE_IT2DFLAT + 1

    IIB = KIB
    IIE = KIE
    IJB = KJB
    IJE = KJE

    ISIZE = ( IIE - IIB + 1_MNHINT64 ) * ( IJE - IJB + 1_MNHINT64 )

    NTOT_ALLOCSIZE_IT2DFLAT = NTOT_ALLOCSIZE_IT2DFLAT + ISIZE

    ipos = MNH_Get_it1dflat( isize )

    ktab(KIB:KIE, KJB:KJE) => it1dflat( NT1DFLAT_POOL_I(ipos) : NT1DFLAT_POOL_I(ipos)+isize-1 )

  END SUBROUTINE MNH_ALLOCATE_IT2DFLAT


  SUBROUTINE MNH_ALLOCATE_IT2DFLAT_SIZE( KTAB, KISIZE, KJSIZE )

    INTEGER, POINTER, CONTIGUOUS , DIMENSION(:,:), INTENT(INOUT) :: KTAB
    INTEGER,                                       INTENT(IN)    :: KISIZE
    INTEGER,                                       INTENT(IN)    :: KJSIZE

    CALL MNH_ALLOCATE_IT2DFLAT( KTAB, 1, KISIZE, 1, KJSIZE )

  END SUBROUTINE MNH_ALLOCATE_IT2DFLAT_SIZE


  SUBROUTINE MNH_ALLOCATE_IT3DFLAT( KTAB, KIB, KIE, KJB, KJE, KKB, KKE )

    INTEGER, POINTER, CONTIGUOUS , DIMENSION(:,:,:), INTENT(INOUT) :: KTAB
    INTEGER,                                         INTENT(IN)    :: KIB
    INTEGER,                                         INTENT(IN)    :: KIE
    INTEGER,                                         INTENT(IN)    :: KJB
    INTEGER,                                         INTENT(IN)    :: KJE
    INTEGER,                                         INTENT(IN)    :: KKB
    INTEGER,                                         INTENT(IN)    :: KKE

    INTEGER                :: IPOS
    INTEGER(KIND=MNHINT64) :: ISIZE
    INTEGER(KIND=MNHINT64) :: IIB, IIE, IJB, IJE, IKB, IKE

    NCALL_MNH_ALLOCATE_IT3DFLAT = NCALL_MNH_ALLOCATE_IT3DFLAT + 1

    IIB = KIB
    IIE = KIE
    IJB = KJB
    IJE = KJE
    IKB = KKB
    IKE = KKE

    ISIZE = ( IIE - IIB + 1_MNHINT64 ) * ( IJE - IJB + 1_MNHINT64 ) * ( IKE - IKB + 1_MNHINT64 )

    NTOT_ALLOCSIZE_IT3DFLAT = NTOT_ALLOCSIZE_IT3DFLAT + ISIZE

    ipos = MNH_Get_it1dflat( isize )

    ktab(KIB:KIE, KJB:KJE, KKB:KKE) => it1dflat( NT1DFLAT_POOL_I(ipos) : NT1DFLAT_POOL_I(ipos)+isize-1 )

  END SUBROUTINE MNH_ALLOCATE_IT3DFLAT


  SUBROUTINE MNH_ALLOCATE_IT3DFLAT_SIZE( KTAB, KISIZE, KJSIZE, KKSIZE )

    INTEGER, POINTER, CONTIGUOUS , DIMENSION(:,:,:), INTENT(INOUT) :: KTAB
    INTEGER,                                         INTENT(IN)    :: KISIZE
    INTEGER,                                         INTENT(IN)    :: KJSIZE
    INTEGER,                                         INTENT(IN)    :: KKSIZE

    CALL MNH_ALLOCATE_IT3DFLAT( KTAB, 1, KISIZE, 1, KJSIZE, 1, KKSIZE )

  END SUBROUTINE MNH_ALLOCATE_IT3DFLAT_SIZE


  ! End Integer 1DFLAT management


  !-------- Real 1DFLAT Pool Managment

  FUNCTION MNH_GET_ZT1DFLAT( KSIZE ) RESULT( KINDEX )

    USE MODD_PARAMETERS, ONLY: NNEGUNDEF

    IMPLICIT NONE

    INTEGER(KIND=MNHINT64), INTENT(IN)  :: KSIZE
    INTEGER                             :: KINDEX

    CHARACTER(LEN=32) :: YAVAIL, YMAX, YSIZE
    INTEGER(KIND=MNHINT64), ALLOCATABLE, DIMENSION (:) :: IT1DFLAT_POOL_R
    INTEGER(KIND=MNHINT64), ALLOCATABLE, DIMENSION (:) :: IT1DFLAT_SIZE_R

    NCALL_MNH_GET_ZT1DFLAT = NCALL_MNH_GET_ZT1DFLAT + 1
    NTOT_GETSIZE_ZT1DFLAT  = NTOT_GETSIZE_ZT1DFLAT + KSIZE

    IF ( NT1DFLAT_POS_R + KSIZE > NT1DFLAT_MAXSIZE_R ) THEN
      print*,"MNH_GET_ZT1DFLAT:: ZT1DFLAT too small, NPMAX_T1DFLAT_R =" , NPMAX_T1DFLAT_R
      print*,"MNH_GET_ZT1DFLAT:: augmente NPMAX_T1DFLAT_R in NAM_CONFZ"
      flush(6)
      WRITE( YSIZE,  '( I0 )' ) KSIZE
      WRITE( YAVAIL, '( I0 )' ) NT1DFLAT_MAXSIZE_R - NT1DFLAT_POS_R
      WRITE( YMAX,   '( I0 )' ) NT1DFLAT_MAXSIZE_R
      call Print_msg( NVERB_FATAL, 'GEN', 'MNH_GET_ZT1DFLAT', 'ZT1DFLAT too small (asked=' // Trim( ysize ) // &
                      ', available=' // Trim( yavail ) // ', total=' // Trim( ymax ) // ')' )
    ELSE
      NT1DFLAT_TOP_R = NT1DFLAT_TOP_R + 1
      KINDEX = NT1DFLAT_TOP_R

      IF ( KINDEX > NPMAX_POOL_T1DFLAT_R ) THEN
        WRITE( YSIZE,  '( I0 )' ) NPMAX_POOL_T1DFLAT_R
        WRITE( YMAX,   '( I0 )' ) NPMAX_POOL_T1DFLAT_R+JPPOOLSTEP_FLAT
        call Print_msg( NVERB_INFO, 'GEN', 'MNH_GET_ZT1DFLAT', 'pool for ZT1DFLAT was too small (' // TRIM( YSIZE ) &
                        // '->' // TRIM( YMAX ) // ')' )

        ALLOCATE( IT1DFLAT_POOL_R(NPMAX_POOL_T1DFLAT_R+JPPOOLSTEP_FLAT) )
        ALLOCATE( IT1DFLAT_SIZE_R(NPMAX_POOL_T1DFLAT_R+JPPOOLSTEP_FLAT) )

        IT1DFLAT_POOL_R(1:NPMAX_POOL_T1DFLAT_R) = NT1DFLAT_POOL_R(:)
        IT1DFLAT_SIZE_R(1:NPMAX_POOL_T1DFLAT_R) = NT1DFLAT_SIZE_R(:)
        IT1DFLAT_POOL_R(NPMAX_POOL_T1DFLAT_R+1:) = NNEGUNDEF
        IT1DFLAT_SIZE_R(NPMAX_POOL_T1DFLAT_R+1:) = NNEGUNDEF

        CALL MOVE_ALLOC( FROM = IT1DFLAT_POOL_R, TO = NT1DFLAT_POOL_R )
        CALL MOVE_ALLOC( FROM = IT1DFLAT_SIZE_R, TO = NT1DFLAT_SIZE_R )

        NPMAX_POOL_T1DFLAT_R = NPMAX_POOL_T1DFLAT_R + JPPOOLSTEP_FLAT
      END IF

#if ( MNH_MEM_ALIGN == 1 )
      ! Align position on alignment boundaries
      IF ( MOD( NT1DFLAT_POS_R, NALIGNSIZE_REAL ) == 0 ) THEN
        NT1DFLAT_POOL_R( KINDEX ) = NT1DFLAT_POS_R + 1
      ELSE
        ! Pad values to boundary
        NT1DFLAT_POOL_R( KINDEX ) = NT1DFLAT_POS_R + ( NALIGNSIZE_REAL - MOD( NT1DFLAT_POS_R-1, NALIGNSIZE_REAL ) )
      END IF
#else
      NT1DFLAT_POOL_R( KINDEX ) = NT1DFLAT_POS_R + 1
#endif
      NT1DFLAT_SIZE_R( KINDEX ) = KSIZE

      NT1DFLAT_POS_R = NT1DFLAT_POOL_R( KINDEX ) + KSIZE - 1

      IF ( NT1DFLAT_TOP_R > NT1DFLAT_TOP_R_MAX ) NT1DFLAT_TOP_R_MAX = NT1DFLAT_TOP_R
      IF ( NT1DFLAT_POS_R > NT1DFLAT_POS_R_MAX ) NT1DFLAT_POS_R_MAX = NT1DFLAT_POS_R
    END IF

  END FUNCTION MNH_GET_ZT1DFLAT


  SUBROUTINE MNH_REL_ZT1DFLAT_N0( KINDEX )

    USE MODD_PARAMETERS, ONLY: NNEGUNDEF

    IMPLICIT NONE

    INTEGER, INTENT(IN) :: KINDEX

    NCALL_MNH_REL_ZT1DFLAT = NCALL_MNH_REL_ZT1DFLAT + 1

    !Release only if last block
    IF ( KINDEX /= NT1DFLAT_TOP_R ) &
      call Print_msg( NVERB_FATAL, 'GEN', 'MNH_REL_ZT1DFLAT_N0', 'trying to release block that is not the last one' )

    NTOT_RELSIZE_ZT1DFLAT = NTOT_RELSIZE_ZT1DFLAT + NT1DFLAT_SIZE_R( KINDEX )

    NT1DFLAT_TOP_R = NT1DFLAT_TOP_R - 1
    NT1DFLAT_POS_R = NT1DFLAT_POS_R - NT1DFLAT_SIZE_R( KINDEX )

    NT1DFLAT_POOL_R( KINDEX ) = NNEGUNDEF
    NT1DFLAT_SIZE_R( KINDEX ) = NNEGUNDEF

  END SUBROUTINE MNH_REL_ZT1DFLAT_N0


  SUBROUTINE MNH_REL_ZT1DFLAT( KTEMP1,  KTEMP2,  KTEMP3,  KTEMP4,  KTEMP5,  KTEMP6,  KTEMP7,  KTEMP8,  KTEMP9,  KTEMP10, &
                               KTEMP11, KTEMP12, KTEMP13, KTEMP14, KTEMP15, KTEMP16, KTEMP17, KTEMP18, KTEMP19, KTEMP20)

    IMPLICIT NONE

    INTEGER,           INTENT(IN) :: KTEMP1, KTEMP2
    INTEGER, OPTIONAL, INTENT(IN) :: KTEMP3, KTEMP4, KTEMP5, KTEMP6, KTEMP7, KTEMP8, KTEMP9
    INTEGER, OPTIONAL, INTENT(IN) :: KTEMP10, KTEMP11, KTEMP12, KTEMP13, KTEMP14, KTEMP15, KTEMP16, KTEMP17, KTEMP18
    INTEGER, OPTIONAL, INTENT(IN) :: KTEMP19, KTEMP20

    IF ( PRESENT( KTEMP20 ) ) CALL MNH_REL_ZT1DFLAT_N0( KTEMP20 )
    IF ( PRESENT( KTEMP19 ) ) CALL MNH_REL_ZT1DFLAT_N0( KTEMP19 )
    IF ( PRESENT( KTEMP18 ) ) CALL MNH_REL_ZT1DFLAT_N0( KTEMP18 )
    IF ( PRESENT( KTEMP17 ) ) CALL MNH_REL_ZT1DFLAT_N0( KTEMP17 )
    IF ( PRESENT( KTEMP16 ) ) CALL MNH_REL_ZT1DFLAT_N0( KTEMP16 )
    IF ( PRESENT( KTEMP15 ) ) CALL MNH_REL_ZT1DFLAT_N0( KTEMP15 )
    IF ( PRESENT( KTEMP14 ) ) CALL MNH_REL_ZT1DFLAT_N0( KTEMP14 )
    IF ( PRESENT( KTEMP13 ) ) CALL MNH_REL_ZT1DFLAT_N0( KTEMP13 )
    IF ( PRESENT( KTEMP12 ) ) CALL MNH_REL_ZT1DFLAT_N0( KTEMP12 )
    IF ( PRESENT( KTEMP11 ) ) CALL MNH_REL_ZT1DFLAT_N0( KTEMP11 )
    IF ( PRESENT( KTEMP10 ) ) CALL MNH_REL_ZT1DFLAT_N0( KTEMP10 )
    IF ( PRESENT( KTEMP9  ) ) CALL MNH_REL_ZT1DFLAT_N0( KTEMP9  )
    IF ( PRESENT( KTEMP8  ) ) CALL MNH_REL_ZT1DFLAT_N0( KTEMP8  )
    IF ( PRESENT( KTEMP7  ) ) CALL MNH_REL_ZT1DFLAT_N0( KTEMP7  )
    IF ( PRESENT( KTEMP6  ) ) CALL MNH_REL_ZT1DFLAT_N0( KTEMP6  )
    IF ( PRESENT( KTEMP5  ) ) CALL MNH_REL_ZT1DFLAT_N0( KTEMP5  )
    IF ( PRESENT( KTEMP4  ) ) CALL MNH_REL_ZT1DFLAT_N0( KTEMP4  )
    IF ( PRESENT( KTEMP3  ) ) CALL MNH_REL_ZT1DFLAT_N0( KTEMP3  )
    CALL MNH_REL_ZT1DFLAT_N0( KTEMP2  )
    CALL MNH_REL_ZT1DFLAT_N0( KTEMP1 )

  END SUBROUTINE MNH_REL_ZT1DFLAT

  SUBROUTINE MNH_ALLOCATE_ZT1DFLAT_SIZE_INT32( PTAB, KIB, KIE )

    REAL, POINTER, CONTIGUOUS , DIMENSION(:), INTENT(INOUT) :: PTAB
    INTEGER(KIND=MNHINT32),                   INTENT(IN)    :: KIB
    INTEGER(KIND=MNHINT32),                   INTENT(IN)    :: KIE
    INTEGER :: ISIZE
    ISIZE = (KIE - KIB + 1)
    CALL MNH_ALLOCATE_ZT1DFLAT_INT32( PTAB, INT( ISIZE, KIND = MNHINT32 ) )

  END SUBROUTINE MNH_ALLOCATE_ZT1DFLAT_SIZE_INT32

  SUBROUTINE MNH_ALLOCATE_ZT1DFLAT_SIZE_INT64( PTAB, KIB, KIE )

    REAL, POINTER, CONTIGUOUS , DIMENSION(:), INTENT(INOUT) :: PTAB
    INTEGER(KIND=MNHINT64),                   INTENT(IN)    :: KIB
    INTEGER(KIND=MNHINT64),                   INTENT(IN)    :: KIE
    INTEGER :: ISIZE
    ISIZE = (KIE - KIB + 1)
    CALL MNH_ALLOCATE_ZT1DFLAT_INT64( PTAB, INT( ISIZE, KIND = MNHINT64 ) )

  END SUBROUTINE MNH_ALLOCATE_ZT1DFLAT_SIZE_INT64

  SUBROUTINE MNH_ALLOCATE_ZT1DFLAT_INT32( PTAB, KSIZE )

    REAL, POINTER, CONTIGUOUS , DIMENSION(:), INTENT(INOUT) :: PTAB
    INTEGER(KIND=MNHINT32),                   INTENT(IN)    :: KSIZE

    CALL MNH_Allocate_zt1dflat_int64( ptab, Int( ksize, kind = MNHINT64 ) )

  END SUBROUTINE MNH_ALLOCATE_ZT1DFLAT_INT32


  SUBROUTINE MNH_ALLOCATE_ZT1DFLAT_INT64( PTAB, KSIZE )

    REAL, POINTER, CONTIGUOUS , DIMENSION(:), INTENT(INOUT) :: PTAB
    INTEGER(KIND=MNHINT64),                   INTENT(IN)    :: KSIZE

    INTEGER :: IPOS

    NCALL_MNH_ALLOCATE_ZT1DFLAT = NCALL_MNH_ALLOCATE_ZT1DFLAT + 1
    NTOT_ALLOCSIZE_ZT1DFLAT     = NTOT_ALLOCSIZE_ZT1DFLAT + KSIZE

    ipos = MNH_Get_zt1dflat( ksize )
    ptab(1:KSIZE) => zt1dflat( NT1DFLAT_POOL_R(ipos) : NT1DFLAT_POOL_R(ipos)+ksize-1 )

  END SUBROUTINE MNH_ALLOCATE_ZT1DFLAT_INT64


  SUBROUTINE MNH_ALLOCATE_ZT2DFLAT( PTAB, KIB, KIE, KJB, KJE )

    REAL, POINTER, CONTIGUOUS , DIMENSION(:,:), INTENT(INOUT) :: PTAB
    INTEGER,                                    INTENT(IN)    :: KIB
    INTEGER,                                    INTENT(IN)    :: KIE
    INTEGER,                                    INTENT(IN)    :: KJB
    INTEGER,                                    INTENT(IN)    :: KJE

    INTEGER                :: IPOS
    INTEGER(KIND=MNHINT64) :: ISIZE
    INTEGER(KIND=MNHINT64) :: IIB, IIE, IJB, IJE

    NCALL_MNH_ALLOCATE_ZT2DFLAT = NCALL_MNH_ALLOCATE_ZT2DFLAT + 1

    IIB = KIB
    IIE = KIE
    IJB = KJB
    IJE = KJE

    ISIZE = ( IIE - IIB + 1_MNHINT64 ) * ( IJE - IJB + 1_MNHINT64 )

    NTOT_ALLOCSIZE_ZT2DFLAT = NTOT_ALLOCSIZE_ZT2DFLAT + ISIZE

    ipos = MNH_Get_zt1dflat( isize )

    ptab(KIB:KIE, KJB:KJE) => zt1dflat( NT1DFLAT_POOL_R(ipos) : NT1DFLAT_POOL_R(ipos)+isize-1 )

  END SUBROUTINE MNH_ALLOCATE_ZT2DFLAT


  SUBROUTINE MNH_ALLOCATE_ZT2DFLAT_SIZE( PTAB, KISIZE, KJSIZE )

    REAL, POINTER, CONTIGUOUS , DIMENSION(:,:), INTENT(INOUT) :: PTAB
    INTEGER,                                    INTENT(IN)    :: KISIZE
    INTEGER,                                    INTENT(IN)    :: KJSIZE

    CALL MNH_ALLOCATE_ZT2DFLAT( PTAB, 1, KISIZE, 1, KJSIZE )

  END SUBROUTINE MNH_ALLOCATE_ZT2DFLAT_SIZE


  SUBROUTINE MNH_ALLOCATE_ZT3DFLAT( PTAB, KIB, KIE, KJB, KJE, KKB, KKE )

    REAL, POINTER, CONTIGUOUS , DIMENSION(:,:,:), INTENT(INOUT) :: PTAB
    INTEGER,                                      INTENT(IN)    :: KIB
    INTEGER,                                      INTENT(IN)    :: KIE
    INTEGER,                                      INTENT(IN)    :: KJB
    INTEGER,                                      INTENT(IN)    :: KJE
    INTEGER,                                      INTENT(IN)    :: KKB
    INTEGER,                                      INTENT(IN)    :: KKE

    INTEGER                :: IPOS
    INTEGER(KIND=MNHINT64) :: ISIZE
    INTEGER(KIND=MNHINT64) :: IIB, IIE, IJB, IJE, IKB, IKE

    NCALL_MNH_ALLOCATE_ZT3DFLAT = NCALL_MNH_ALLOCATE_ZT3DFLAT + 1

    IIB = KIB
    IIE = KIE
    IJB = KJB
    IJE = KJE
    IKB = KKB
    IKE = KKE

    ISIZE = ( IIE - IIB + 1_MNHINT64 ) * ( IJE - IJB + 1_MNHINT64 ) * ( IKE - IKB + 1_MNHINT64 )

    NTOT_ALLOCSIZE_ZT3DFLAT = NTOT_ALLOCSIZE_ZT3DFLAT + ISIZE

    ipos = MNH_Get_zt1dflat( isize )

    ptab(KIB:KIE, KJB:KJE, KKB:KKE) => zt1dflat( NT1DFLAT_POOL_R(ipos) : NT1DFLAT_POOL_R(ipos)+isize-1 )

  END SUBROUTINE MNH_ALLOCATE_ZT3DFLAT


  SUBROUTINE MNH_ALLOCATE_ZT3DFLAT_SIZE( PTAB, KISIZE, KJSIZE, KKSIZE )

    REAL, POINTER, CONTIGUOUS , DIMENSION(:,:,:), INTENT(INOUT) :: PTAB
    INTEGER,                                      INTENT(IN)    :: KISIZE
    INTEGER,                                      INTENT(IN)    :: KJSIZE
    INTEGER,                                      INTENT(IN)    :: KKSIZE

    CALL MNH_ALLOCATE_ZT3DFLAT( PTAB, 1, KISIZE, 1, KJSIZE, 1, KKSIZE )

  END SUBROUTINE MNH_ALLOCATE_ZT3DFLAT_SIZE


  SUBROUTINE MNH_ALLOCATE_ZT4DFLAT( PTAB, KIB, KIE, KJB, KJE, KKB, KKE, KPB, KPE )

    REAL, POINTER, CONTIGUOUS , DIMENSION(:,:,:,:), INTENT(INOUT) :: PTAB
    INTEGER,                                        INTENT(IN)    :: KIB
    INTEGER,                                        INTENT(IN)    :: KIE
    INTEGER,                                        INTENT(IN)    :: KJB
    INTEGER,                                        INTENT(IN)    :: KJE
    INTEGER,                                        INTENT(IN)    :: KKB
    INTEGER,                                        INTENT(IN)    :: KKE
    INTEGER,                                        INTENT(IN)    :: KPB
    INTEGER,                                        INTENT(IN)    :: KPE

    INTEGER                :: IPOS
    INTEGER(KIND=MNHINT64) :: ISIZE
    INTEGER(KIND=MNHINT64) :: IIB, IIE, IJB, IJE, IKB, IKE, IPB, IPE

    NCALL_MNH_ALLOCATE_ZT4DFLAT = NCALL_MNH_ALLOCATE_ZT4DFLAT + 1

    IIB = KIB
    IIE = KIE
    IJB = KJB
    IJE = KJE
    IKB = KKB
    IKE = KKE
    IPB = KPB
    IPE = KPE

    ISIZE = ( IIE - IIB + 1_MNHINT64 ) * ( IJE - IJB + 1_MNHINT64 ) * ( IKE - IKB + 1_MNHINT64 ) * ( IPE - IPB + 1_MNHINT64 )

    NTOT_ALLOCSIZE_ZT4DFLAT = NTOT_ALLOCSIZE_ZT4DFLAT + ISIZE

    ipos = MNH_Get_zt1dflat( isize )

    ptab(KIB:KIE, KJB:KJE, KKB:KKE, KPB:KPE ) => zt1dflat( NT1DFLAT_POOL_R(ipos) : NT1DFLAT_POOL_R(ipos)+isize-1 )

  END SUBROUTINE MNH_ALLOCATE_ZT4DFLAT


  SUBROUTINE MNH_ALLOCATE_ZT4DFLAT_SIZE( PTAB, KISIZE, KJSIZE, KKSIZE, KPSIZE )

    REAL, POINTER, CONTIGUOUS , DIMENSION(:,:,:,:), INTENT(INOUT) :: PTAB
    INTEGER,                                        INTENT(IN)    :: KISIZE
    INTEGER,                                        INTENT(IN)    :: KJSIZE
    INTEGER,                                        INTENT(IN)    :: KKSIZE
    INTEGER,                                        INTENT(IN)    :: KPSIZE
    INTEGER                                                     :: KINDEX

    CALL MNH_ALLOCATE_ZT4DFLAT( PTAB, 1, KISIZE, 1, KJSIZE, 1, KKSIZE, 1, KPSIZE )

  END SUBROUTINE MNH_ALLOCATE_ZT4DFLAT_SIZE


  ! End Real 1DFLAT management



  SUBROUTINE MNH_MEM_POSITION_PIN( HSUBR )
    ! Function that stores the current position of the different preallocated arrays in the position pool
    CHARACTER(LEN=*), OPTIONAL, INTENT(IN) :: HSUBR !Name of the calling subroutine

    CHARACTER(LEN=32) :: YMAX, YSIZE, YNPOOL_POS
    TYPE(TMNH_MEM_POS), ALLOCATABLE, DIMENSION(:) :: TZPOOL

    NCALL_MNH_MEM_POSITION_PIN = NCALL_MNH_MEM_POSITION_PIN + 1

    NPOOL_POS = NPOOL_POS + 1
    IF ( NPOOL_POS > NPOOL_POS_MAX ) NPOOL_POS_MAX = NPOOL_POS

    IF ( NPOOL_POS > NMAXSIZE_POOL_POS ) THEN
      WRITE( YSIZE,  '( I0 )' ) NMAXSIZE_POOL_POS
      WRITE( YMAX,   '( I0 )' ) NMAXSIZE_POOL_POS + JPPOOLSTEP_FLAT
      IF ( PRESENT( HSUBR) ) THEN
        call Print_msg( NVERB_INFO, 'GEN', 'MNH_MEM_POSITION_PIN', TRIM( HSUBR ) // 'pool was too small (' // TRIM( YSIZE ) &
                        // '->' // TRIM( YMAX ) // ')' )
      ELSE
        call Print_msg( NVERB_INFO, 'GEN', 'MNH_MEM_POSITION_PIN', 'pool was too small (' // TRIM( YSIZE ) &
                        // '->' // TRIM( YMAX ) // ')' )
      END IF

      ALLOCATE( TZPOOL(NMAXSIZE_POOL_POS + JPPOOLSTEP_FLAT) )

      TZPOOL(1:NMAXSIZE_POOL_POS) = TPOOL_POS(:)

      CALL MOVE_ALLOC( FROM = TZPOOL, TO = TPOOL_POS )

      NMAXSIZE_POOL_POS = NMAXSIZE_POOL_POS + JPPOOLSTEP_FLAT
    END IF

    IF ( PRESENT( HSUBR ) ) THEN
      TPOOL_POS(NPOOL_POS)%CNAME = TRIM( HSUBR )
    ELSE
      TPOOL_POS(NPOOL_POS)%CNAME = TRIM( CPOSNAME_DEFAULT )
    END IF

    TPOOL_POS(NPOOL_POS)%NPOS_G = NT1DFLAT_POS_G !Position in the logical array
    TPOOL_POS(NPOOL_POS)%NPOS_I = NT1DFLAT_POS_I !Position in the integer array
    TPOOL_POS(NPOOL_POS)%NPOS_R = NT1DFLAT_POS_R !Position in the real array

    TPOOL_POS(NPOOL_POS)%NPOS_POOL_G = NT1DFLAT_TOP_G !Position in the logical pool array
    TPOOL_POS(NPOOL_POS)%NPOS_POOL_I = NT1DFLAT_TOP_I !Position in the logical pool array
    TPOOL_POS(NPOOL_POS)%NPOS_POOL_R = NT1DFLAT_TOP_R !Position in the logical pool array

    WRITE( YNPOOL_POS ,  '( I0 )' ) NPOOL_POS
    call Print_msg( NVERB_DEBUG, 'GEN', 'END MNH_MEM_POSITION_PIN', TRIM( HSUBR ) // ' NPOOL_POS=' // YNPOOL_POS )

  END SUBROUTINE MNH_MEM_POSITION_PIN


  SUBROUTINE MNH_MEM_RELEASE( HSUBR )
    ! Function that set the current position in the different preallocated arrays
    ! to the last values in the position pool
    ! This can be used to release previously allocated memory
    USE MODD_PARAMETERS, ONLY: NNEGUNDEF

    CHARACTER(LEN=*), OPTIONAL, INTENT(IN) :: HSUBR !Name of the calling subroutine

    CHARACTER(LEN=NPOSNAMESZ) :: YNAME
    CHARACTER(LEN=32) :: YNPOOL_POS

    
    NCALL_MNH_MEM_RELEASE = NCALL_MNH_MEM_RELEASE + 1

    IF ( NPOOL_POS < 1 ) THEN
      IF ( PRESENT( HSUBR ) ) THEN
        call Print_msg( NVERB_FATAL, 'GEN', 'MNH_MEM_RELEASE', &
                        TRIM( HSUBR ) // ': trying to release pool memory but nothing pinned' )
      ELSE
        call Print_msg( NVERB_FATAL, 'GEN', 'MNH_MEM_RELEASE', 'trying to release pool memory but nothing pinned' )
      END IF
    END IF

    IF ( PRESENT( HSUBR ) ) THEN
      YNAME = TRIM( HSUBR )
    ELSE
      YNAME = TRIM( CPOSNAME_DEFAULT )
    END IF

    IF ( YNAME /= TPOOL_POS(NPOOL_POS)%CNAME ) THEN
      call Print_msg( NVERB_ERROR, 'GEN', 'MNH_MEM_RELEASE', 'asked to release ' // TRIM( YNAME) &
                      // ' but expected ' // TRIM( TPOOL_POS(NPOOL_POS)%CNAME ) )
    END IF

    !Stats for sizes
    NTOT_RELSIZE_GT1DFLAT = NTOT_RELSIZE_GT1DFLAT + NT1DFLAT_POS_G - TPOOL_POS(NPOOL_POS)%NPOS_G
    NTOT_RELSIZE_IT1DFLAT = NTOT_RELSIZE_IT1DFLAT + NT1DFLAT_POS_I - TPOOL_POS(NPOOL_POS)%NPOS_I
    NTOT_RELSIZE_ZT1DFLAT = NTOT_RELSIZE_ZT1DFLAT + NT1DFLAT_POS_R - TPOOL_POS(NPOOL_POS)%NPOS_R

    !Stats for pools
    NCALL_MNH_REL_GT1DFLAT = NCALL_MNH_REL_GT1DFLAT + NT1DFLAT_TOP_G - TPOOL_POS(NPOOL_POS)%NPOS_POOL_G
    NCALL_MNH_REL_IT1DFLAT = NCALL_MNH_REL_IT1DFLAT + NT1DFLAT_TOP_I - TPOOL_POS(NPOOL_POS)%NPOS_POOL_I
    NCALL_MNH_REL_ZT1DFLAT = NCALL_MNH_REL_ZT1DFLAT + NT1DFLAT_TOP_R - TPOOL_POS(NPOOL_POS)%NPOS_POOL_R

    !Clean up pools
    NT1DFLAT_POOL_G( TPOOL_POS(NPOOL_POS)%NPOS_POOL_G + 1 : NT1DFLAT_TOP_G ) = NNEGUNDEF
    NT1DFLAT_SIZE_G( TPOOL_POS(NPOOL_POS)%NPOS_POOL_G + 1 : NT1DFLAT_TOP_G ) = NNEGUNDEF
    NT1DFLAT_POOL_I( TPOOL_POS(NPOOL_POS)%NPOS_POOL_I + 1 : NT1DFLAT_TOP_I ) = NNEGUNDEF
    NT1DFLAT_SIZE_I( TPOOL_POS(NPOOL_POS)%NPOS_POOL_I + 1 : NT1DFLAT_TOP_I ) = NNEGUNDEF
    NT1DFLAT_POOL_R( TPOOL_POS(NPOOL_POS)%NPOS_POOL_R + 1 : NT1DFLAT_TOP_R ) = NNEGUNDEF
    NT1DFLAT_SIZE_R( TPOOL_POS(NPOOL_POS)%NPOS_POOL_R + 1 : NT1DFLAT_TOP_R ) = NNEGUNDEF

    NT1DFLAT_POS_G = TPOOL_POS(NPOOL_POS)%NPOS_G !Position in the logical array
    NT1DFLAT_POS_I = TPOOL_POS(NPOOL_POS)%NPOS_I !Position in the integer array
    NT1DFLAT_POS_R = TPOOL_POS(NPOOL_POS)%NPOS_R !Position in the real array

    NT1DFLAT_TOP_G = TPOOL_POS(NPOOL_POS)%NPOS_POOL_G !Position in the logical pool array
    NT1DFLAT_TOP_I = TPOOL_POS(NPOOL_POS)%NPOS_POOL_I !Position in the logical pool array
    NT1DFLAT_TOP_R = TPOOL_POS(NPOOL_POS)%NPOS_POOL_R !Position in the logical pool array

    TPOOL_POS(NPOOL_POS)%NPOS_G = NNEGUNDEF
    TPOOL_POS(NPOOL_POS)%NPOS_I = NNEGUNDEF
    TPOOL_POS(NPOOL_POS)%NPOS_R = NNEGUNDEF

    TPOOL_POS(NPOOL_POS)%NPOS_POOL_G = NNEGUNDEF
    TPOOL_POS(NPOOL_POS)%NPOS_POOL_I = NNEGUNDEF
    TPOOL_POS(NPOOL_POS)%NPOS_POOL_R = NNEGUNDEF

    NPOOL_POS = NPOOL_POS - 1

    WRITE( YNPOOL_POS ,  '( I0 )' ) NPOOL_POS
    call Print_msg( NVERB_DEBUG, 'GEN', 'END MNH_MEM_RELEASE', TRIM( HSUBR ) // ' NPOOL_POS=' // YNPOOL_POS )

  END SUBROUTINE MNH_MEM_RELEASE


  SUBROUTINE PRINT_FLATPOOL_STATS()
    cmnhmsg(1) = 'MNH memory pool size):'
    Write( cmnhmsg(2), "( '  Entries (current / max used / max avail) = ', I10, '/', I10, '/', I10, &
            ' (max is automatically increased if necessary)' )" ) NPOOL_POS, NPOOL_POS_MAX, NMAXSIZE_POOL_POS
    call Print_msg( NVERB_INFO, 'GEN', 'FLAT_STATS' )

    cmnhmsg(1) = 'MNH memory pool: number of calls:'
    Write( cmnhmsg(2), "( '  MNH_MEM_POSITION_PIN  = ', I20 )" ) NCALL_MNH_MEM_POSITION_PIN
    Write( cmnhmsg(3), "( '  MNH_MEM_RELEASE       = ', I20 )" ) NCALL_MNH_MEM_RELEASE
    Write( cmnhmsg(4), "( '-------------------------', '--------------------' )" )
    call Print_msg( NVERB_INFO, 'GEN', 'FLAT_STATS' )

    cmnhmsg(1) = 'LOGICAL flat pool: Number of calls:'
    Write( cmnhmsg(2), "( '  MNH_GET_GT1DFLAT        = ', I20 )" ) NCALL_MNH_GET_GT1DFLAT
    Write( cmnhmsg(3), "( '    MNH_ALLOCATE_GT1DFLAT = ', I20 )" ) NCALL_MNH_ALLOCATE_GT1DFLAT
    Write( cmnhmsg(4), "( '    MNH_ALLOCATE_GT2DFLAT = ', I20 )" ) NCALL_MNH_ALLOCATE_GT2DFLAT
    Write( cmnhmsg(5), "( '    MNH_ALLOCATE_GT3DFLAT = ', I20 )" ) NCALL_MNH_ALLOCATE_GT3DFLAT
    Write( cmnhmsg(6), "( '  MNH_REL_GT1DFLAT        = ', I20 )" ) NCALL_MNH_REL_GT1DFLAT
    call Print_msg( NVERB_INFO, 'GEN', 'FLAT_STATS' )

    cmnhmsg(1) = 'LOGICAL flat pool: Maximum sizes:'
    Write( cmnhmsg(2), "( '  Entries (current / max used / max avail) = ', I10, '/', I10, '/', I10, &
            ' (max is automatically increased if necessary)' )" ) NT1DFLAT_TOP_G, NT1DFLAT_TOP_G_MAX, NPMAX_POOL_T1DFLAT_G
    Write( cmnhmsg(3), "( '  Memory  (current / max used / max avail) = ', I20, '/', I20, '/', I20 )" ) &
           NT1DFLAT_POS_G, NT1DFLAT_POS_G_MAX, NT1DFLAT_MAXSIZE_G
    call Print_msg( NVERB_INFO, 'GEN', 'FLAT_STATS' )

    cmnhmsg(1) = 'LOGICAL flat pool: Total provided and released sizes (in bytes):'
    Write( cmnhmsg(2), "( '  Provided = ', I20 )" ) NTOT_GETSIZE_GT1DFLAT
    Write( cmnhmsg(3), "( '    1D     = ', I20 )" ) NTOT_ALLOCSIZE_GT1DFLAT
    Write( cmnhmsg(4), "( '    2D     = ', I20 )" ) NTOT_ALLOCSIZE_GT2DFLAT
    Write( cmnhmsg(5), "( '    3D     = ', I20 )" ) NTOT_ALLOCSIZE_GT3DFLAT
    Write( cmnhmsg(6), "( '  Released = ', I20 )" ) NTOT_RELSIZE_GT1DFLAT
    Write( cmnhmsg(7), "( '-------------', '--------------------' )" )
    call Print_msg( NVERB_INFO, 'GEN', 'FLAT_STATS' )


    cmnhmsg(1) = 'INTEGER flat pool: Number of calls:'
    Write( cmnhmsg(2), "( '  MNH_GET_IT1DFLAT        = ', I20 )" ) NCALL_MNH_GET_IT1DFLAT
    Write( cmnhmsg(3), "( '    MNH_ALLOCATE_IT1DFLAT = ', I20 )" ) NCALL_MNH_ALLOCATE_IT1DFLAT
    Write( cmnhmsg(4), "( '    MNH_ALLOCATE_IT2DFLAT = ', I20 )" ) NCALL_MNH_ALLOCATE_IT2DFLAT
    Write( cmnhmsg(5), "( '    MNH_ALLOCATE_IT3DFLAT = ', I20 )" ) NCALL_MNH_ALLOCATE_IT3DFLAT
    Write( cmnhmsg(6), "( '  MNH_REL_IT1DFLAT        = ', I20 )" ) NCALL_MNH_REL_IT1DFLAT
    call Print_msg( NVERB_INFO, 'GEN', 'FLAT_STATS' )

    cmnhmsg(1) = 'INTEGER flat pool: Maximum sizes:'
    Write( cmnhmsg(2), "( '  Entries (current / max used / max avail) = ', I10, '/', I10, '/', I10, &
            ' (max is automatically increased if necessary)' )" ) NT1DFLAT_TOP_I, NT1DFLAT_TOP_I_MAX, NPMAX_POOL_T1DFLAT_I
    Write( cmnhmsg(3), "( '  Memory  (current / max used / max avail) = ', I20, '/', I20, '/', I20 )" ) &
           NT1DFLAT_POS_I, NT1DFLAT_POS_I_MAX, NT1DFLAT_MAXSIZE_I
    call Print_msg( NVERB_INFO, 'GEN', 'FLAT_STATS' )

    cmnhmsg(1) = 'INTEGER flat pool: Total provided and released sizes (in bytes):'
    Write( cmnhmsg(2), "( '  Provided = ', I20 )" ) NTOT_GETSIZE_IT1DFLAT
    Write( cmnhmsg(3), "( '    1D     = ', I20 )" ) NTOT_ALLOCSIZE_IT1DFLAT
    Write( cmnhmsg(4), "( '    2D     = ', I20 )" ) NTOT_ALLOCSIZE_IT2DFLAT
    Write( cmnhmsg(5), "( '    3D     = ', I20 )" ) NTOT_ALLOCSIZE_IT3DFLAT
    Write( cmnhmsg(6), "( '  Released = ', I20 )" ) NTOT_RELSIZE_IT1DFLAT
    Write( cmnhmsg(7), "( '-------------', '--------------------' )" )
    call Print_msg( NVERB_INFO, 'GEN', 'FLAT_STATS' )


    cmnhmsg(1) = 'REAL flat pool: Number of calls:'
    Write( cmnhmsg(2), "( '  MNH_GET_ZT1DFLAT        = ', I20 )" ) NCALL_MNH_GET_ZT1DFLAT
    Write( cmnhmsg(3), "( '    MNH_ALLOCATE_ZT1DFLAT = ', I20 )" ) NCALL_MNH_ALLOCATE_ZT1DFLAT
    Write( cmnhmsg(4), "( '    MNH_ALLOCATE_ZT2DFLAT = ', I20 )" ) NCALL_MNH_ALLOCATE_ZT2DFLAT
    Write( cmnhmsg(5), "( '    MNH_ALLOCATE_ZT3DFLAT = ', I20 )" ) NCALL_MNH_ALLOCATE_ZT3DFLAT
    Write( cmnhmsg(6), "( '    MNH_ALLOCATE_ZT4DFLAT = ', I20 )" ) NCALL_MNH_ALLOCATE_ZT4DFLAT
    Write( cmnhmsg(7), "( '  MNH_REL_ZT1DFLAT        = ', I20 )" ) NCALL_MNH_REL_ZT1DFLAT
    call Print_msg( NVERB_INFO, 'GEN', 'FLAT_STATS' )

    cmnhmsg(1) = 'REAL flat pool: Maximum sizes:'
    Write( cmnhmsg(2), "( '  Entries (current / max used / max avail) = ', I10, '/', I10, '/', I10, &
            ' (max is automatically increased if necessary)' )" ) NT1DFLAT_TOP_R, NT1DFLAT_TOP_R_MAX, NPMAX_POOL_T1DFLAT_R
    Write( cmnhmsg(3), "( '  Memory  (current / max used / max avail) = ', I20, '/', I20, '/', I20 )" ) &
           NT1DFLAT_POS_R, NT1DFLAT_POS_R_MAX, NT1DFLAT_MAXSIZE_R
    call Print_msg( NVERB_INFO, 'GEN', 'FLAT_STATS' )

    cmnhmsg(1) = 'REAL flat pool: Total provided and released sizes (in bytes):'
    Write( cmnhmsg(2), "( '  Provided = ', I20 )" ) NTOT_GETSIZE_ZT1DFLAT
    Write( cmnhmsg(3), "( '    1D     = ', I20 )" ) NTOT_ALLOCSIZE_ZT1DFLAT
    Write( cmnhmsg(4), "( '    2D     = ', I20 )" ) NTOT_ALLOCSIZE_ZT2DFLAT
    Write( cmnhmsg(5), "( '    3D     = ', I20 )" ) NTOT_ALLOCSIZE_ZT3DFLAT
    Write( cmnhmsg(6), "( '    4D     = ', I20 )" ) NTOT_ALLOCSIZE_ZT4DFLAT
    Write( cmnhmsg(7), "( '  Released = ', I20 )" ) NTOT_RELSIZE_ZT1DFLAT
    Write( cmnhmsg(8), "( '-------------', '--------------------' )" )
    call Print_msg( NVERB_INFO, 'GEN', 'FLAT_STATS' )

  END SUBROUTINE PRINT_FLATPOOL_STATS


  SUBROUTINE MNH_CHECK_IN_ZT3D(HSUB)
    IMPLICIT NONE

    CHARACTER(LEN=*) :: HSUB

    !print*,"MNH_CHECK_IN_ZT3D => " , NT3D_TOP_CURRENT_INDEX+1 ,  HSUB
    NT3D_TOP_CURRENT_INDEX = NT3D_TOP_CURRENT_INDEX + 1
    NT3D_TOP_CURRENT(NT3D_TOP_CURRENT_INDEX) = NT3D_TOP
  END SUBROUTINE MNH_CHECK_IN_ZT3D

  SUBROUTINE MNH_CHECK_OUT_ZT3D(HSUB)
    IMPLICIT NONE

    CHARACTER(LEN=*) :: HSUB
    
    !print*,"MNH_CHECK_OUT_ZT3D <= " ,  NT3D_TOP_CURRENT_INDEX , HSUB
    IF ( NT3D_TOP_CURRENT(NT3D_TOP_CURRENT_INDEX) .NE.  NT3D_TOP ) THEN
        WRITE( *, '( "MNH_CHECK_OUT_ZT3D : NT3D_TOP_CURRENT .NE. NT3D_TOP (",2I8,")" )' )  NT3D_TOP_CURRENT ,  NT3D_TOP
        call Print_msg( NVERB_ERROR, 'GEN', 'MNH_CHECK_OUT_ZT3D', ' CHECK IN/OUT MISTASK ' )
     ELSE
        NT3D_TOP_CURRENT_INDEX = NT3D_TOP_CURRENT_INDEX - 1
    END IF 
  END SUBROUTINE MNH_CHECK_OUT_ZT3D

END MODULE MODE_MNH_ZWORK
